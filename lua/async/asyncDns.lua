---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/6 7:53 PM
---

require("eclass")

local system = require("common.system")
local psocket = require("posix.sys.socket")
local pystring = require("pystring")
local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api
local CasyncBase = require("async.asyncBase")

local class = class
local CasyncDns = class("asyncDns", CasyncBase)

local ipairs = ipairs
local print = print
local io_open = io.open
local liteAssert = system.liteAssert
local coReport = system.coReport
local running = coroutine.running
local yield = coroutine.yield
local resume = coroutine.resume
local startswith = pystring.startswith
local split = pystring.split
local new_socket = psocket.socket
local psendto = psocket.sendto
local char = string.char
local len = string.len
local format = string.format
local byte = string.byte
local concat = table.concat
local c_api_b_close = c_api.b_close

local function lookup_server()
    local f = io_open("/etc/resolv.conf")
    local server
    liteAssert(f, "dns config not found.")
    for line in f:lines() do
        if startswith(line, "nameserver") then
            local res = split(line)
            server = res[2]
            break
        end
    end

    f:close()
    return server
end

function CasyncDns:_init_(beaver)
    self._serverIP = lookup_server()
    liteAssert(self._serverIP)

    local fd, err, errno = new_socket(psocket.AF_INET, psocket.SOCK_DGRAM, 0)
    liteAssert(fd, err)


    CasyncBase._init_(self, beaver, fd, 10)  -- accept never overtime.
end

local function packQuery(domain)
    local cnt = 0
    local queries = {}
    local head = char(
            0x12, 0x34, -- Query ID
            0x01, 0x00, -- Standard query
            0x00, 0x01, -- Number of questions
            0x00, 0x00, -- Number of answers
            0x00, 0x00, -- Number of authority records
            0x00, 0x00  -- Number of additional records
    )
    cnt = cnt + 1
    queries[cnt] = head

    local names = split(domain, ".")
    for _, name in ipairs(names) do
        cnt = cnt + 1
        queries[cnt] = char(len(name))
        cnt = cnt + 1
        queries[cnt] = name
    end
    cnt = cnt + 1
    local tail = char(
            0x00, -- End of domain name
            0x00, 0x01, -- Type A record
            0x00, 0x01 -- Class IN
    )
    queries[cnt] = tail

    local query = concat(queries)
    return query
end

function CasyncDns:_setup(fd, tmo)
    local res, msg
    local beaver = self._beaver
    local serverIP = self._serverIP
    local len, err, errno
    local tDist = {family=psocket.AF_INET, addr=serverIP, port=53}

    while true do
        beaver:co_set_tmo(fd, -1)
        local co, domain = yield()

        local query = packQuery(domain)
        len, err, errno = psendto(fd, query, tDist)
        if not len then
            print(err, errno)
            res, msg = resume(co, nil)
            coReport(co, res, msg)
            break
        end

        beaver:co_set_tmo(fd, tmo)
        res, err, errno = beaver:read(fd, 512)
        if not res then
            print(err, errno)
            res, msg = resume(co, nil)
            system.coReport(co, res, msg)
            break
        else
            local ip = format("%d.%d.%d.%d", byte(res, -4, -1))
            res, msg = resume(co, ip)
            coReport(co, res, msg)
        end
    end
    self:stop()
    c_api_b_close(fd)
end

function CasyncDns:request(domain)
    local res, msg
    local co = running()
    res, msg = resume(self._co, co, domain)
    coReport(self._co, res, msg)
    return yield()
end

return CasyncDns
