---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/6 7:53 PM
---

require("eclass")

local system = require("common.system")
local dnsParser = require("common.dnsParser")
local psocket = require("posix.sys.socket")
local pystring = require("pystring")
local sockComm = require("common.sockComm")
local CasyncBase = require("async.asyncBase")

local class = class
local CasyncDns = class("asyncDns", CasyncBase)

local mathHuge = math.huge
local random = math.random
local pairs = pairs
local next = next
local ipairs = ipairs
local time = os.time
local print = print
local io_open = io.open
local liteAssert = system.liteAssert
local coReport = system.coReport
local create = coroutine.create
local yield = coroutine.yield
local resume = coroutine.resume
local status = coroutine.status
local running = coroutine.running
local startswith = pystring.startswith
local split = pystring.split
local new_socket = psocket.socket
local psendto = psocket.sendto
local char = string.char
local len = string.len
local format = string.format
local byte = string.byte
local type = type
local concat = table.concat
local insert = table.insert
local error = error
local isIPv4 = sockComm.isIPv4

local dnsOvertime
local local_timer
local freshDns
local wakeDns
local reqId = 0
local serverIPs = {}
local searchSuffix = {}

local function randomIp(ips)
    if not ips then
        return nil
    end
    local idx = random(#ips)
    return ips[idx]
end

local function lookupServer()
    local f = io_open("/etc/resolv.conf")
    if not f then
        error("dns config not found.")
    end
    for line in f:lines() do
        if startswith(line, "nameserver") then
            local res = split(line)
            if isIPv4(res[2]) then
                insert(serverIPs, res[2])
            end
        elseif startswith(line, "search") then
            local res = split(line)
            for i = 2, #res do
                searchSuffix[i - 1] = res[i]
            end
        end
    end
    f:close()
end

local function lookupLocal(path)
    path = path or "/etc/hosts"
    local f = io_open(path)
    liteAssert(f, "dns config not found.")
    local domains = {}
    for line in f:lines() do
        local ss = split(line)
        local ip = ss[1]
        if isIPv4(ip) then
            for i =2, #ss do
                local domain = ss[i]
                if domains[domain] then
                    insert(domains[domain], ip)
                else
                    domains[domain] = {ip}
                end
            end
        end
    end
    f:close()

    local res = {}
    for domain, ips in pairs(domains) do
        res[domain] = {ips, mathHuge}
    end
    return res
end

function CasyncDns:_init_(beaver, fresh, wake, timer, overtime)
    local_timer = timer
    dnsOvertime = overtime
    lookupServer()
    liteAssert(serverIPs)

    local fd, err, errno = new_socket(psocket.AF_INET, psocket.SOCK_DGRAM, 0)
    liteAssert(fd, err)

    self._working = false  -- for working flag, 
    self._requesting = {}  -- domain -> {fid, coId}.  just one member 
    self._requestQue = {}  -- domain -> {fid, coId}.
    freshDns = fresh
    wakeDns = wake

    local res = lookupLocal()
    for k, v in pairs(res) do
        freshDns(k, v)
    end

    CasyncBase._init_(self, beaver, fd, 5)  -- accept never overtime.
end

local function packQuery(domain)
    local cnt = 0
    local queries = {}
    reqId = reqId + 1
    if reqId > 65535 then
        reqId = 0
    end
    local high = reqId % 256
    local low = reqId / 256
    local head = char(
            low, high, -- Query ID
            0x01, 0x00, -- Standard query
            0x00, 0x01, -- Number of questions
            0x00, 0x00, -- Number of answers
            0x00, 0x00, -- Number of authority records
            0x00, 0x00  -- Number of additional records
    )
    cnt = cnt + 1
    queries[cnt] = head

    if not domain:find(".", 1, true) then
        if #searchSuffix < 0 then
            return nil
        end
        domain = domain .. "." .. searchSuffix[1]
    end

    local names = split(domain, ".")
    for _, name in ipairs(names) do
        cnt = cnt + 1
        queries[cnt] = char(len(name))
        cnt = cnt + 1
        queries[cnt] = name
    end
    cnt = cnt + 1
    local tail = char(
            0x00, -- End of domain name
            0x00, 0x01, -- Type A record
            0x00, 0x01 -- Class IN
    )
    queries[cnt] = tail

    local query = concat(queries)
    return query
end

local function wakesDns(requesting, domain, ips)
    local requests = requesting[domain]
    local over = time() + dnsOvertime
    for _, req in ipairs(requests) do  -- req contains {fid, coId}
        wakeDns(domain, randomIp(ips), over, req[1], req[2])
    end
    requesting[domain] = nil
end

local function getIPFromRec(rec, e)
    local c, ips = 1, {}
    if rec then
        if type(rec.answers) == "table" then
            for _, an in ipairs(rec.answers) do
                if an.type == "A" then
                    local content = an.content
                    if isIPv4(content) then
                        ips[c] = content
                        c = c + 1
                    end
                end
            end
        end
        if c > 1 then
            return ips
        else
            return nil, "no dns request from dns req."
        end
    else
        print("bad dns req.", e)
        return nil, error
    end
end

local function getThread(beaver, domain, ip, tmo, coWake)
    local size, fd, err, errno, res, msg
    fd, err = new_socket(psocket.AF_INET, psocket.SOCK_DGRAM, 0)
    liteAssert(fd, err)
    beaver:co_bind(fd)

    local tDist = {family=psocket.AF_INET, addr=ip, port=53}
    local query = packQuery(domain)

    size, err, errno = psendto(fd, query, tDist)
    if not size or size ~= #query then
        print(format("sendto dns requst %s to %s, return size %d, hopo: %d, err: %s, errno: %d", domain, ip, size or -1, #query, err, errno))
        beaver:co_exit(fd)
        -- always resume from dns thread, so, do not wake up coWake.
        return
    end
    beaver:co_set_tmo(fd, tmo)
    res, err, errno = beaver:read(fd, 512)  -- will yield back.

    if status(coWake) == "suspended" then  -- may wake for cancel.
        local ips = nil
        if res then
            local parser = dnsParser.new(res)
            local rec, e = parser:parse()
            ips, e = getIPFromRec(rec, e)
            if not ips then
                print("dns parse failed.", e)
            end
        else
            print(format("sendto dns requst %s to %s, return %s, errno: %d", domain, ip, err, errno))
        end
        res, msg = resume(coWake, ip, ips)
        coReport(coWake, res, msg)
    end
    beaver:co_exit(fd)
end

local function dnsGets(beaver, domain, tmo)
    local res, msg
    local nowCo = running()
    local cos = {}
    for _, ip in ipairs(serverIPs) do
        local co = create(getThread)
        res, msg = resume(co, beaver, domain, ip, tmo, nowCo)
        coReport(co, res, msg)
        cos[ip] = co
    end

    local ips, ip = nil, nil
    repeat
        ip, ips = yield()  -- wake from getThread
        cos[ip] = nil  -- release record.
        if ips then
            for head, co in pairs(cos) do
                if ip ~= head then
                    res, msg = resume(co, nil)  -- to kill other getThread
                    coReport(co, res, msg)
                    cos[head] = nil  -- release record.
                end
            end
        else
            if not next(cos) then  -- get none.
                return nil
            end
        end
    until ips
    return ips
end

function CasyncDns:_setup(fd, tmo)
    local requesting = self._requesting
    local requstQue = self._requestQue

    local beaver = self._beaver
    local failed = 0
    beaver:co_set_tmo(fd, -1)

    while true do
        self._working = false
        local _ = yield()   -- tVar contains {fid, coId}
        self._working = true

        while true do
            local domain, tVar = next(requstQue)
            if not domain then  -- requstQue has picked up, back to yield.
                break
            end

            requstQue[domain] = nil
            requesting[domain] = tVar

            local ips = nil
            local try = 0
            repeat
                ips = dnsGets(beaver, domain, tmo)
                if ips then
                    freshDns(domain, {ips, time() + dnsOvertime})
                    failed = 0
                else
                    try = try + 1
                    local_timer:msleep(99)  -- try delayed 99ms for net. do not use masterVar sleep, it will nest required.
                end
            until ips or try > 10

            wakesDns(requesting, domain, ips)
            if not ips then
                failed = failed + 1
            end

            if failed > 10 then
                print("dns failed too many times.")  -- should never occur.
                os.exit(1)
                break
            end
        end
    end
    self:stop()
end

function CasyncDns:request(domain, tVar) -- tVar contains {fid, coId}
    if self._requesting[domain] then  -- already in requesting, delayed.
        insert(self._requesting[domain], tVar)
        return
    end

    local que = self._requestQue

    if que[domain] then
        insert(que[domain], {tVar})
    else
        que[domain] = {tVar}
    end

    if not self._working then  -- wake up setup
        local co = self._co
        local res, msg
        res, msg = resume(co, domain)
        coReport(co, res, msg)
    end
end

return CasyncDns
