---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/6 7:53 PM
---

require("eclass")

local system = require("common.system")
local dnsParser = require("common.dnsParser")
local psocket = require("posix.sys.socket")
local pystring = require("pystring")
local sockComm = require("common.sockComm")
local CasyncBase = require("async.asyncBase")

local class = class
local CasyncDns = class("asyncDns", CasyncBase)

local mathHuge = math.huge
local random = math.random
local pairs = pairs
local ipairs = ipairs
local time = os.time
local print = print
local io_open = io.open
local liteAssert = system.liteAssert
local coReport = system.coReport
local yield = coroutine.yield
local resume = coroutine.resume
local startswith = pystring.startswith
local split = pystring.split
local new_socket = psocket.socket
local psendto = psocket.sendto
local char = string.char
local len = string.len
local format = string.format
local byte = string.byte
local type = type
local concat = table.concat
local insert = table.insert
local error = error
local isIPv4 = sockComm.isIPv4

local freshDns
local wakeDns
local reqId = 0
local serverIP
local searchSuffix = {}

local function randomIp(ips)
    if not ips then
        return nil
    end
    local idx = random(#ips)
    return ips[idx]
end

local function lookupServer()
    local f = io_open("/etc/resolv.conf")
    if not f then
        error("dns config not found.")
    end
    for line in f:lines() do
        if startswith(line, "nameserver") then
            local res = split(line)
            serverIP = res[2]
            break
        elseif startswith(line, "search") then
            local res = split(line)
            for i = 2, #res do
                searchSuffix[i - 1] = res[i]
            end
        end
    end
    f:close()
end

local function lookupLocal(path)
    path = path or "/etc/hosts"
    local f = io_open(path)
    liteAssert(f, "dns config not found.")
    local domains = {}
    for line in f:lines() do
        local ss = split(line)
        local ip = ss[1]
        if isIPv4(ip) then
            for i =2, #ss do
                local domain = ss[i]
                if domains[domain] then
                    insert(domains[domain], ip)
                else
                    domains[domain] = {ip}
                end
            end
        end
    end
    f:close()

    local res = {}
    for domain, ips in pairs(domains) do
        res[domain] = {ips, mathHuge}
    end
    return res
end

function CasyncDns:_init_(beaver, fresh, wake)
    lookupServer()
    liteAssert(serverIP)

    local fd, err, errno = new_socket(psocket.AF_INET, psocket.SOCK_DGRAM, 0)
    liteAssert(fd, err)

    self._requesting = {}  -- domain -> fid, coId
    freshDns = fresh
    wakeDns = wake

    local res = lookupLocal()
    for k, v in pairs(res) do
        freshDns(k, v)
    end

    CasyncBase._init_(self, beaver, fd, 10)  -- accept never overtime.
end

local function packQuery(domain)
    local cnt = 0
    local queries = {}
    reqId = reqId + 1
    if reqId > 65535 then
        reqId = 0
    end
    local high = reqId % 256
    local low = reqId / 256
    local head = char(
            low, high, -- Query ID
            0x01, 0x00, -- Standard query
            0x00, 0x01, -- Number of questions
            0x00, 0x00, -- Number of answers
            0x00, 0x00, -- Number of authority records
            0x00, 0x00  -- Number of additional records
    )
    cnt = cnt + 1
    queries[cnt] = head

    if not domain:find(".", 1, true) then
        if #searchSuffix < 0 then
            return nil
        end
        domain = domain .. "." .. searchSuffix[1]
    end

    local names = split(domain, ".")
    for _, name in ipairs(names) do
        cnt = cnt + 1
        queries[cnt] = char(len(name))
        cnt = cnt + 1
        queries[cnt] = name
    end
    cnt = cnt + 1
    local tail = char(
            0x00, -- End of domain name
            0x00, 0x01, -- Type A record
            0x00, 0x01 -- Class IN
    )
    queries[cnt] = tail

    local query = concat(queries)
    return query
end

local function wakesDns(requesting, domain, ips)
    local requests = requesting[domain]
    for _, req in ipairs(requests) do  -- req contains {fid, coId}
        wakeDns(domain, randomIp(ips), req[1], req[2])
    end
    requesting[domain] = nil
end

local function getIPFromRec(rec, e)
    local c, ips = 1, {}
    if rec then
        if type(rec.answers) == "table" then
            for _, an in ipairs(rec.answers) do
                if an.type == "A" then
                    ips[c] = an.content
                    c = c + 1
                end
            end
        end
        if c > 1 then
            return ips
        else
            return nil, "no dns request from dns req."
        end
    else
        print("bad dns req.", e)
        return nil, error
    end
end

function CasyncDns:_setup(fd, tmo)
    local res
    local beaver = self._beaver
    local size, err, errno
    local tDist = {family=psocket.AF_INET, addr=serverIP, port=53}
    local failed = 0

    while true do
        beaver:co_set_tmo(fd, -1)
        local domain, tVar = yield()   -- tVar contains {fid, coId}

        local query = packQuery(domain)
        if query then
            size, err, errno = psendto(fd, query, tDist)
            if size then
                beaver:co_set_tmo(fd, tmo)
                res, err, errno = beaver:read(fd, 512)
                local ips
                if res then
                    local parser = dnsParser.new(res)
                    local rec, e = parser:parse()
                    ips, e = getIPFromRec(rec, e)
                    if not ips then
                        print("dns parse failed.", e)
                        failed = failed + 1
                    else
                        freshDns(domain, {ips, time()})
                        failed = 0
                    end
                else
                    print("dns read fialed.", err, errno)
                    failed = failed + 1
                end
                wakesDns(self._requesting, domain, ips)
            else
                print("dns sentto fialed.", err, errno)
                wakesDns(self._requesting, domain, nil)
                failed = failed + 1
            end

            if failed > 256 then
                print("dns failed too many times.")  -- should never occur.
                os.exit(1)
                break
            end
        else
            wakesDns(self._requesting, domain, nil)
        end
    end
    self:stop()
end

function CasyncDns:request(domain, tVar) -- tVar contains {fid, coId}
    if self._requesting[domain] then  -- already in requesting, delayed.
        insert(self._requesting[domain], tVar)
        return
    end

    self._requesting[domain] = {tVar}
    local res, msg
    res, msg = resume(self._co, domain, tVar)
    coReport(self._co, res, msg)
end

return CasyncDns
