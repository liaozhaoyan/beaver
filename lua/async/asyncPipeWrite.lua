---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/3 4:37 AM
---

require("eclass")

local system = require("common.system")
local CasyncBase = require("async.asyncBase")

local class = class
local CasyncPipeWrite = class("asyncPipeWrite", CasyncBase)

local ipairs = ipairs
local type = type
local print = print
local coReport = system.coReport
local running = coroutine.running
local yield = coroutine.yield
local resume = coroutine.resume
local status = coroutine.status
local format = string.format

function CasyncPipeWrite:_init_(beaver, fd, tmo)
    self._tmo = tmo

    self._working = false
    self._c = 1
    self._que = {}
    CasyncBase._init_(self, beaver, fd, -1)
end

function CasyncPipeWrite:_setup(fd, tmo)
    self._coSelf = running()

    local beaver = self._beaver
    tmo = self._tmo
    beaver:co_set_tmo(fd, tmo)
    local c = self._c
    while true do
        self._working = false
        local stream = yield()
        if type(stream) == "string" then
            self._working = true
            beaver:co_yield()  -- release call from CasyncPipeWrite:write
            while c < self._c do
                local ret, err, errno = beaver:pipeWrite(fd, self._que[c])  -->pipe write may yield out
                c = c + 1
                if not ret then -- fd close event?
                    print(format("pipe write fd %d closed.", fd))
                    break
                end
                self._que[c] = nil
            end
        else  -- fd close event?
            print(format("write fd %d closed. for event", fd))
            break
        end
    end
    self:stop()
end

function CasyncPipeWrite:write(stream)
    self._que[self._c] = stream
    self._c = self._c + 1
    if not self._working then
        local co = self._coSelf
        local res, msg = resume(co, "run.")
        coReport(co, res, msg)
    end
end

return CasyncPipeWrite