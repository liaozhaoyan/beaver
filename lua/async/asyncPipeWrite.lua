---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/3 4:37 AM
---

require("eclass")

local system = require("common.system")
local CasyncBase = require("async.asyncBase")
local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local CasyncPipeWrite = class("asyncPipeWrite", CasyncBase)

function CasyncPipeWrite:_init_(beaver, fd, tmo)
    self._toWake = coroutine.running()
    self._tmo = tmo
    CasyncBase._init_(self, beaver, fd, -1)
end

function CasyncPipeWrite:_setup(fd, tmo)
    local res, msg
    local co = self._toWake
    self._coSelf = coroutine.running()

    local beaver = self._beaver
    tmo = self._tmo
    while true do
        local stream = coroutine.yield()
        if type(stream) == "string" then
            beaver:co_set_tmo(fd, tmo)
            local ret, err, errno = beaver:pipeWrite(fd, stream)  -->pipe write may yield out
            if coroutine.status(co) == "normal" then  --> write not yield
                coroutine.yield(ret, err, errno)
            else
                res, msg = coroutine.resume(co, ret, err, errno)
                system.coReport(co, res, msg)
            end

            beaver:co_set_tmo(fd, -1)

            if not ret then -- fd close event?
                print(string.format("fd %d closed.", fd))
                break
            end
        else  -- fd close event?
            print(string.format("fd %d closed.", fd))
            break
        end
    end
    self:stop()
    c_api._bclose(fd)
end

function CasyncPipeWrite:write(stream)
    local res, msg, err, errno = coroutine.resume(self._coSelf, stream)
    system.coReport(self._coSelf, res, msg)
    if msg then  -- write function may write to pipe, if stream is short enough, write will return at once
        local ret = msg
        res, msg = coroutine.resume(self._coSelf)  -->task will yield after write success.
        system.coReport(self._coSelf, res, msg)
        return ret, err, errno
    else --> the pipe call from if stream is too long, the task may be yield.
        return coroutine.yield()
    end
end

return CasyncPipeWrite