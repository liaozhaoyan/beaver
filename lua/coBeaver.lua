---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/1 1:41 AM
---
--- 2024.1.1: CcoBeaver is to manage all beaver coroutine events
local require = require
require("eclass")

local system = require("common.system")
local CbeaverIO = require("beaverIO")

local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local class = class
local CcoBeaver = class("coBeaver", CbeaverIO)

local c_new = c_type.new
local liteAssert = system.liteAssert
local coReport = system.coReport
local c_poll_is_in = c_api.poll_is_in
local c_poll_is_out = c_api.poll_is_out
local c_poll_is_close = c_api.poll_is_close
local c_api_poll_fds = c_api.poll_fds
local format = string.format
local time = os.time
local pairs = pairs
local error = error
local print = print
local insert = table.insert
local create = coroutine.create
local resume = coroutine.resume
local status = coroutine.status
local yield = coroutine.yield
local running = coroutine.running
local traceback = debug.traceback

function CcoBeaver:_init_()
    self._yields = {}
    CbeaverIO._init_(self)
end

function CcoBeaver:_del_()
    CbeaverIO._del_(self)
end

function CcoBeaver:co_add(cb, fd)
    self:add(fd)  -- add to epoll fd, defined in beaverIO.lua, will set fd to async mode.
    local co = create(function(o, obj, afd, tmo)  cb(o, obj, afd, tmo) end)
    self._cos[fd] = co  -- _cos defined in beaverIO.lua

    return co
end

function CcoBeaver:co_bind(fd, co)  --bind fd event to coroutine.
    self:add(fd)
    self._cos[fd] = co or running()
end

function CcoBeaver:co_exit(fd)
    self:remove(fd)
    self._cos[fd] = nil -- _cos defined in beaverIO.lua
end

function CcoBeaver:co_yield(...)
    self._yields[running()] = 1
    -- insert(self._yields, running())
    return yield(...)
end

local function runCo(co, e)
    if status(co) == "dead" then  -- coroutine dead, do nothing
        return
    end
    local res, msg = resume(co, e)
    if not res then
        print("resume error.", traceback(co))
    end
    coReport(co, res, msg)
end
-- 
local function _pollFd(cos, nes)
    local e = c_new("native_event_t")
    for i = 0, nes.num - 1 do
        local ev = nes.evs[i];
        local fd = ev.fd

        local co = cos[fd]
        -- assert(co, string.format("fd: %d not setup.", fd))
        if co then -- coroutine event may closed, then the coroutine will free.
            -- The handling order of epoll should be in -> close -> read.
            e.fd = fd
            if c_poll_is_in(ev) > 0 then
                e.ev_in = 1
                runCo(co, e)
                e.ev_in = 0
            end
            if c_poll_is_close(ev) > 0 then
                e.ev_close = 1
                runCo(co, e)
                e.ev_close = 0
            end
            if c_poll_is_out(ev) > 0 then
                e.ev_out = 1
                runCo(co, e)
                e.ev_out = 0
            end
        end
    end
    return 0
end

function CcoBeaver:poll()
    local efd = self._efd
    local cos = self._cos
    while true do
        local nes = c_new("native_events_t")
        local ret = c_api_poll_fds(efd, 1000, nes)
        if ret < 0 then
            error(format("epoll failed, errno: %d", -ret))
        end
        _pollFd(cos, nes)
        for co, _ in pairs(self._yields) do
            local res, msg = resume(co)
            coReport(co, res, msg)
        end
        self._yields = {}
    end
end

return CcoBeaver
