---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/1 1:41 AM
---
--- 2024.1.1: CcoBeaver is to manage all beaver coroutine events

require("eclass")

local system = require("common.system")
local socket = require("posix.sys.socket")
local unistd = require("posix.unistd")
local CbeaverIO = require("beaverIO")

local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local CcoBeaver = class("coBeaver", CbeaverIO)

function CcoBeaver:_init_()
    CbeaverIO._init_(self)

    self._cos = {}
    self._last = os.time()
    self._tmoCos = {}
    self._tmoFd = {}
end

function CcoBeaver:_del_()
    CbeaverIO._del_(self)
end

function CcoBeaver:co_set_tmo(fd, tmo)
    assert(tmo < 0 or tmo >= 10, "illegal tmo value.")
    self._tmoFd[fd] = tmo
    if tmo > 0 then
        self._tmoCos[fd] = os.time()
    end
end

function CcoBeaver:co_get_tmo(fd)
    return self._tmoFd[fd]
end

function CcoBeaver:co_add(obj, cb, fd, tmo)
    tmo = tmo or 60   -- default tmo time is 60s, -1 means never overtime.
    if tmo > 0 then
        assert(tmo >= 10)
    end
    self._tmoFd[fd] = tmo  -- record fd time out

    self:add(fd)  -- add to epoll fd
    local co = coroutine.create(function(o, obj, fd, tmo)  cb(o, obj, fd, tmo) end)
    self._cos[fd] = co

    local res, msg = coroutine.resume(co, obj, fd, tmo)
    system.coReport(co, res, msg)
    return co
end

function CcoBeaver:co_exit(fd)
    self:remove(fd)

    self._tmoFd[fd] = nil
    self._cos[fd] = nil
    self._tmoCos[fd] = nil
end


local function dictCopy(tbl)
    local cp = {}
    assert(type(tbl) == "table")

    for k, v in pairs(tbl) do
        cp[k] = v
    end
    return cp
end

function CcoBeaver:_co_check(now, checkedFd)
    local res, msg
    if now - self._last >= 1 then
        -- ! coroutine will del self._tmoCos cell in loop, so create a mirror table for safety
        --local tmos = dictCopy(self._tmoCos)
        for fd, tmo in pairs(self._tmoCos) do
            if checkedFd[fd] then  -- the fd has last checked.
                goto continue
            end
            local tmoFd = self._tmoFd[fd]  -- tmoFd record the socket fd set over time
            if tmoFd and tmoFd > 0 and now - tmo >= tmoFd then  -- overtime
                local co = self._cos[fd]
                if co and coroutine.status(co) == "suspended" then
                    local e = c_type.new("native_event_t")  -- need to close this fd
                    e.ev_close = 1
                    e.fd = fd
                    print(fd, "is over time.", tmo, now - tmo)
                    res, msg = coroutine.resume(co, e)
                    system.coReport(co, res, msg)
                end
            end
            ::continue::
        end
        self._last = now
    end
end

function CcoBeaver:_pollFd(nes)
    local now_time = os.time()
    local checkedFd = {}
    for i = 0, nes.num - 1 do
        local e = nes.evs[i];
        local fd = e.fd

        local co = self._cos[fd]
        -- assert(co, string.format("fd: %d not setup.", fd))
        if co then -- coroutine event may closed.
            self._tmoCos[fd] = now_time
            checkedFd[fd] = now_time
            local res, msg = coroutine.resume(co, e)
            system.coReport(co, res, msg)
        end
    end
    self:_co_check(now_time, checkedFd)
end

function CcoBeaver:poll()
    local efd = self._efd
    while true do
        local nes = c_type.new("native_events_t")
        local res = c_api.poll_fds(efd, 1, nes)

        if res < 0 then
            error(string.format("epoll failed, errno: %d", -res))
        end

        self:_pollFd(nes)
    end
end

return CcoBeaver
