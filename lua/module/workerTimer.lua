---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/14 11:32 PM
---
local require = require
require("eclass")

local system = require("common.system")
local lrbtree = require("lrbtree")
local CasyncTimer = require("async.asyncTimer")
local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local class = class
local CworkerTimer = class("workTimer")

local liteAssert = system.liteAssert
local coReport = system.coReport
local create = coroutine.create
local yield = coroutine.yield
local resume = coroutine.resume
local status = coroutine.status
local running = coroutine.running
local format = string.format
local type = type
local error = error
local time_io_calc = c_api.time_io_calc

local delayDict = {}

local function rbCmp(node1, node2)
    return node1.ms >= node2.ms and 1 or -1
end

function CworkerTimer:_init_(beaver)
    self._tree = lrbtree.new(rbCmp)
    self._co = create(self.run)
    self._timer = CasyncTimer.new(beaver, self._co)
    delayDict = {}
end

function CworkerTimer:_del_()
    self._timer:trig(-1)
    delayDict = {}
end

local function wakeProc(co)
    local res, msg
    if status(co) == "suspended" then -- may wake from timer thread. 
        res, msg = resume(co, 1)
        coReport(co, res, msg)
        return false
    else
        return true   -- wake from timer thread, upper function should direct return.
    end
end

local function insertNode(tree, node, co)
    local res = tree:insert(node)
    liteAssert(res, "insert to rbtree failed.")

    return wakeProc(co)
end

local function _addTimer(tree, co, period, timer, coTimer)
    local first = tree:first()
    if first then  -- timeList has member
        local node = delayDict[co]
        if node then  -- is already in the time rbtree
            if not tree:delete(node) then    -- drop from rbtree at first.
                error(format("beaver report bug: drop from rbtree failed."))
            end
            if period > 0 then  -- update timer
                node.period = period
                node.ms = time_io_calc(period)
                insertNode(tree, node, coTimer)  -- wake up CworkerTimer:run to update timer.
            else  -- should delete from delayDict
                delayDict[co] = nil
                if first == node then -- the first node
                    first = tree:first() -- for next first
                    if first then  -- has member, to next timer.
                        wakeProc(co) -- wake up CworkerTimer:run to update timer.
                    else -- empty, disable the timer.
                        -- if period < 0, will not wake up CworkerTimer:run, so, should update here.
                        timer:update(0)
                    end
                end
            end
        else -- not in. should create.
            if period > 0 then
                node = {co = co, period = period, ms = time_io_calc(period)}
                delayDict[co] = node  -- record here.
                insertNode(tree, node, coTimer)
            end
        end
    else    -- timer is empty.
        if period > 0 then
            local node = {co = co, period = period, ms = time_io_calc(period)}
            delayDict[co] = node
            insertNode(tree, node, coTimer)
        end
    end
end

-- will call yield.
function CworkerTimer:msleep(period)
    local co = running()
    local tree = self._tree
    local coTimer = self._co

    _addTimer(tree, co, period, self._timer, coTimer)
    if period > 0 then
        return yield(0)  -- always return 0 to tell _setup function continue to sleep.
    else
        return period
    end
end

-- will not call yield.
function CworkerTimer:wait(co, period)
    local tree = self._tree
    local coTimer = self._co

    _addTimer(tree, co, period, self._timer, coTimer)
end

function CworkerTimer:start()  -- the tree should at least one node
    local res, msg
    res, msg = resume(self._co, self)
    coReport(self._co, res, msg)
end

local function procTimer(node)
    local co = node.co
    delayDict[co] = nil  -- delete from record table.
    if status(co) == "suspended" then
        local res, msg = resume(co, node.period)
        coReport(co, res, msg)
    end
    return node.ms
end

function CworkerTimer:run()
    local e, node
    local tree = self._tree
    local timer = self._timer
    local lastMs = 0

    while true do
        e = yield()
        if type(e) ~= "number" then
            error(format("beaver report bug: timer event type: %s", type(e)))
        end
        if e == 1 then   -- wake for new timer.
            node = tree:first()
            if lastMs ~= node.ms then
                lastMs = node.ms
                timer:update(lastMs)
            end
        else  -- e 0 wake for fd timer
            node = tree:pop()
            local ms = procTimer(node)
            node = tree:first()
            while node and node.ms == ms do  -- check the same node
                procTimer(tree:pop())
                node = tree:first()
            end
            if node then -- the delay tree may be empty.
                timer:update(node.ms)
                lastMs = node.ms
            else
                lastMs = 0
            end
        end
    end
end

return CworkerTimer
