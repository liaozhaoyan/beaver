---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/14 11:32 PM
---

require("eclass")

local system = require("common.system")
local lrbtree = require("lrbtree")
local CasyncTimer = require("async.asyncTimer")

local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local CmasterTimer = class("masterTimer")

local function rbCmp(node1, node2)
    return node1.ms - node2.ms
end

function CmasterTimer:_init_(beaver, cbWake)
    self._tree = lrbtree.new(rbCmp)
    self._co = coroutine.create(self.run)
    self._timer = CasyncTimer.new(beaver, self._co)
    self._cbWake = cbWake
end

function CmasterTimer:_del_()
    self._timer:trig(-1)
end

function CmasterTimer:add(node)
    -- node should contains
    -- loop: loop times, only integer
    -- period：should > 10 ms，
    -- optional:
    -- fid: if fid is zero, coId means inner co, otherwise means work write id to send.
    -- coId: coroutine id.
    local tree = self._tree
    local res, msg
    local loop = node.loop
    local period = node.period
    assert(loop % 1 == 0, "illegal loop value.")
    assert(period >= 10 and period % 1 == 0, "illegal ms value.")

    local first = tree:first()  -- caution：tree may empty
    node.ms = c_api.time_io_calc(period)
    res = tree:insert(node)
    assert(res, "insert to rbtree failed.")
    if not first then  -- empty tree, wake coroutine， in func else wakeup from empty.
        if coroutine.status(self._co) == "suspended" then
            res, msg = coroutine.resume(self._co)
            system.coReport(self._co, res, msg)
        else
            return
        end
    elseif first.ms > node.ms then -- first is nil means empty tree
        self._timer:update(node.ms)
    end
end

function CmasterTimer:start()  -- the tree should at least one node
    local res, msg
    res, msg = coroutine.resume(self._co, self)
    system.coReport(self._co, res, msg)
end

function CmasterTimer:run()
    local res
    local node
    local tree = self._tree
    local timer = self._timer
    local lastMs, ms = 0
    local cbWake = self._cbWake

    while true do
        node = tree:first()
        if node then -- not an empty tree.
            ms = node.ms
            if lastMs ~= ms then  -- last time update
                res = timer:update(ms)
                coroutine.yield()  -- wait for timer_fd wake.
            end

            node = tree:pop() -- node may change after yield.
            lastMs = node.ms
            node.loop = node.loop - 1
            cbWake(node)

            if node.loop > 0 then
                node.ms = c_api.time_io_calc(node.period)
                res = tree:insert(node)
                assert(res, "insert to rbtree failed.")
            end
        else  -- wake up from empty.
            coroutine.yield()
        end
    end
end

return CmasterTimer