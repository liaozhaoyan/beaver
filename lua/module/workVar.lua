---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/6 11:39 AM
---

local M = {}
local system = require("common.system")

local cjson = require("cjson.safe")

local var = {
    -- for server module manage.
    pingpong = {},
    dnsReq = {},
    upstream = {},
    httpServer = {},

    -- for connect module manage
    httpReq = {},

    -- for redis client
    redis = {},

    -- for dns manager
    dnsWait = {},   -- just for dns.
    dnsId  = 1,     -- dns request co id,

    -- for multi delay, loop >= 1
    periodWakeCo = {},   -- multi delayed,
    periodWakeId = 1,    -- index
}

function M.workerSetPipeOut(coOut)
    var.coOut = coOut
end

local function regThreadId(arg)
    var.id = arg.id
    local func = {
        func = "workerReg",
        arg = {
            id = arg.id
        }
    }

    local res, msg = coroutine.resume(var.coOut, cjson.encode(func))
    system.coReport(var.coOut, res, msg)

    if var.setupCb then
        local call = var.setupCb.func
        local args = var.setupCb.args
        call(args)
        var.setupCb = nil  -- clear after call.
    end
end

local function echoDns(arg)
    local coId = arg.coId
    local co = var.dnsWait[coId]

    local res, msg =  coroutine.resume(co, arg.domain, arg.ip)
    system.coReport(co, res, msg)
    var.dnsWait[coId] = nil   -- free wait.
end

local function echoWake(arg)
    local res, msg
    local coId = arg.coId
    local co = var.periodWakeCo[coId]

    res, msg = coroutine.resume(co, arg.period)
    system.coReport(co, res, msg)
    if arg.loop == 0 then
        var.periodWakeCo[coId] = nil   -- free wait.
    end
end

local funcTable = {
    regThreadId = function(arg) return regThreadId(arg)  end,
    echoDns     = function(arg) return echoDns(arg)  end,
    echoWake    = function(arg) return echoWake(arg)  end,
}

function M.call(arg)
    return funcTable[arg.func](arg.arg)
end

function M.workerSetVar(beaver, conf, yaml)
    var.thread = {
        beaver = beaver,
        conf = conf,
        yaml = yaml
    }
end

function M.workerGetVar()
    return var.thread
end

function M.bindAdd(m, fd, co)
    assert(not var[m][fd], string.format("%s bind socket is already in use.", m))
    var[m][fd] = {
        co = co,
        addrs = {},
        cos = {}
    }
end

function M.clientAdd(m, bfd, fd, co, addr)
    assert(not var[m][bfd].cos[fd], string.format("%s work socket is already in use.", m))
    var[m][bfd].cos[fd] = co
    var[m][bfd].addrs[fd] = addr
end

function M.clientDel(m, fd)
    for _, m in pairs(var[m]) do
        for i, _ in pairs(m.cos) do
            if fd == i then
                m.addrs[i] = nil
                m.cos[i] = nil
                return
            end
        end
    end
    system.dumps(var[m])
    error(string.format("fd: %d is not register.", fd))
end

function M.connectAdd(m, fd, co)
    assert(not var[m][fd], string.format("%s connect socket is already working.", m))
    var[m][fd] = co
end

function M.connectDel(m, fd)
    assert(var[m][fd], "%s connect socket is not working.", m)
    var[m][fd] = nil
end

local function dnsGetCoId()
    local ret = var.dnsId
    var.dnsWait[ret] = coroutine.running()
    var.dnsId = var.dnsId + 1
    return ret
end

function M.dnsReq(domain)
    local func = {
        func = "reqDns",
        arg = {
            id = var.id,
            domain = domain,
            coId = dnsGetCoId()
        }
    }

    local res, msg = coroutine.resume(var.coOut, cjson.encode(func))
    system.coReport(var.coOut, res, msg)
    local domain, ip = coroutine.yield()
    return domain, ip
end

local function periodWakeGetId()
    local ret = var.periodWakeId
    var.periodWakeCo[ret] = coroutine.running()
    var.periodWakeId = var.periodWakeId + 1
    return ret
end

function M.periodWake(period, loop)
    assert(period >= 1, "period arg should greater than 1.")
    assert(loop >= 1, "loop should greater than 1.")
    local func = {
        func = "reqPeriodWake",
        arg = {
            id = var.id,
            coId = periodWakeGetId(),
            period = period,
            loop = loop,
        }
    }

    local res, msg = coroutine.resume(var.coOut, cjson.encode(func))
    system.coReport(var.coOut, res, msg)
    return coroutine.yield()
end

function M.msleep(ms)
    return M.periodWake(ms, 1)
end

function M.setCb(func, args)
    var.setupCb = {
        func = func,
        args = args
    }
end

return M