---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/6 11:39 AM
---

local M = {}
local require = require
local system = require("common.system")
local CasyncAccept = require("async.asyncAccept")
local sockComm = require("common.sockComm")
local dnsmatch = require("common.dnsmatch")
local httpComm = require("http.httpComm")
local buffer = require("string.buffer")

local mathHuge = math.huge
local type = type
local next = next
local pairs = pairs
local error = error
local pipeEncode = buffer.encode
local time = os.time
local format = string.format
local liteAssert = system.liteAssert
local coReport = system.coReport
local isIPv4 = sockComm.isIPv4
local create = coroutine.create
local running = coroutine.running
local yield = coroutine.yield
local resume = coroutine.resume
local status = coroutine.status
local isdns = dnsmatch.isdns
local setEncoding = httpComm.setEncoding

local timer
local dnsOvertime = 30

local var = {
    -- for server module manage.
    pingpong = {},
    dnsReq = {},
    upstream = {},
    httpServer = {},
    tcpServer = {},

    -- for connect module manage
    httpReq = {},

    -- for redis client
    redis = {},

    -- for dns manager
    dnsWait = {},   -- just for dns.
    dnsId  = 1,     -- dns request co id,
    dnsBuf = {},   --> domain -> ip, overtime

    -- for pingpong
    pingWait = {},   -- just for pingpong.
    pingId  = 1,     -- ping request co id,
}

local function getDnsBuf(dnsBuf, domain)
    local now = time()
    if dnsBuf[domain] then
        if now > dnsBuf[domain][2] then
            dnsBuf[domain] = nil
        else
            return dnsBuf[domain][1]
        end
    end
end

function M.getIp(host)
    local domain, ip
    if isIPv4(host) then
        return host
    else
        ip = getDnsBuf(var.dnsBuf, host)
        if ip then
            return ip
        end
        if not isdns(host) then
            return nil, format("bad dns: host %s", host)
        end
        domain, ip = M.dnsReq(host)
        if not ip then
            return nil, format("bad dns: host %s, domain %s", host, domain)
        end
    end
    return ip
end

function M.workerSetPipeOut(coOut)
    var.coOut = coOut
end

local function pipeOut(stream)
    local co = var.coOut
    local res, msg = resume(co, stream)
    coReport(co, res, msg)
end

-- arg2: thread id
local function regThreadId(arg)
    var.id = arg[2]
    local func = {
        "workerReg",
        arg[2]
    }

    pipeOut(pipeEncode(func))

    if var.setupCb then
        local call = var.setupCb.func
        local args = var.setupCb.args
        call(args)
        var.setupCb = nil  -- clear after call.
    end
end

-- arg2: coId
-- arg3: domain
-- arg4: ip
-- arg5: overtime
local function echoDns(arg)
    local coId = arg[2]
    local co = var.dnsWait[coId]

    local domain, ip, over = arg[3], arg[4], arg[5]
    over = over == -1 and mathHuge or over
    var.dnsBuf[domain] = {ip, over}
    if status(co) == "suspended" then
        local res, msg = resume(co, domain, ip)
        coReport(co, res, msg)
    end
    var.dnsWait[coId] = nil   -- free wait.
end

-- arg2: coId
-- arg3: strings
-- arg4: seq
local function pong(arg)  -- refer to masterVar ping function.
    local coId = arg[2]
    local co = var.pingWait[coId]

    if status(co) =="suspended" then
        local res, msg = resume(co, arg[3], arg[4])
        coReport(co, res, msg)
    end
    var.pingWait[coId] = nil
end

local funcTable = {
    regThreadId = function(arg) return regThreadId(arg)  end,
    echoDns     = function(arg) return echoDns(arg)  end,
    pong        = function(arg) return pong(arg)  end,
}

function M.call(arg)
    return funcTable[arg[1]](arg)
end

local function stripOverTimeDns(dnsBuf)
    local msleep = M.msleep
    while true do
        msleep(1000 * dnsOvertime / 5)
        local now = time()
        local domain, buf

        repeat
            domain, buf = next(dnsBuf, domain)
            if domain and now > buf[2] then
                dnsBuf[domain] = nil  -- strip.
            end
        until not domain
    end
end

local function stripDns(dnsBuf)
    local co = create(stripOverTimeDns)
    local res, msg = resume(co, dnsBuf)
    coReport(co, res, msg)
end

function M.workerSetVar(beaver, conf, yaml)
    timer = beaver:setupTimer()
    stripDns(var.dnsBuf)  -- strip overtime dns, to anti-dns-flood.
    var.thread = {
        beaver = beaver,
        conf = conf,
        yaml = yaml
    }
    if yaml.worker.clientCoding then
        setEncoding(yaml.worker.clientCoding)
    end
end

function M.workerGetVar()
    return var.thread
end

function M.bindAdd(m, fd, co)
    liteAssert(not var[m][fd], format("%s bind socket is already in use.", m))
    var[m][fd] = {
        co = co,
        addrs = {},
        cos = {}
    }
end

function M.clientAdd(m, bfd, fd, co, addr)
    liteAssert(not var[m][bfd].cos[fd], format("%s work socket is already in use.", m))
    var[m][bfd].cos[fd] = co
    var[m][bfd].addrs[fd] = addr
end

function M.clientDel(m, fd)
    for _, m in pairs(var[m]) do
        for i, _ in pairs(m.cos) do
            if fd == i then
                m.addrs[i] = nil
                m.cos[i] = nil
                return
            end
        end
    end
    system.dumps(var[m])
    error(format("fd: %d is not register.", fd))
end

function M.connectAdd(m, fd, co)
    liteAssert(not var[m][fd], format("%s connect socket is already working.", m))
    var[m][fd] = co
end

function M.connectDel(m, fd)
    liteAssert(var[m][fd], format("%s connect socket is not working.", m))
    var[m][fd] = nil
end

local function dnsGetCoId()
    local ret = var.dnsId
    var.dnsWait[ret] = running()
    var.dnsId = var.dnsId + 1
    return ret
end

function M.log(level, msg)
    local func = {
        "log",
        level,
        msg
    }
    pipeOut(pipeEncode(func))
end

function M.dnsReq(domain)
    local func = {
        "reqDns",
        var.id,
        dnsGetCoId(),
        domain
    }

    pipeOut(pipeEncode(func))
    local ip
    domain, ip = yield()  -- resume from echoDns
    return domain, ip
end

local function pingGetCoId()
    local ret = var.pingId
    var.pingWait[ret] = running()
    var.pingId = var.pingId + 1
    return ret
end

-- ping master, resume from pong fucntion.
-- @param s: string
-- @return: s string, seq int
function M.pingMaster(s)
    local func = {
        "ping",
        var.id,
        pingGetCoId(),
        s
    }
    pipeOut(pipeEncode(func))
    return yield()  -- resume from pong fucntion.
end

function M.msleep(ms)
    return timer:msleep(ms)
end

function M.wait(co, ms)
    timer:wait(co, ms)
end

function M.setCb(func, args)
    var.setupCb = {
        func = func,
        args = args
    }
end

local ChttpInst = require("http.httpInst")
local instTable = {
    httpServer = function(conf)
        local app = require(format("app.%s", conf.entry))
        local inst = ChttpInst.new()
        app.new(inst, conf)
        return inst
    end,
    tcpServer = function(conf)
        local app = require(format("app.%s", conf.entry))
        return app.new(conf)
    end
}

local function setupInst(conf)
    local func = instTable[conf.func]
    if func then
        return func(conf)
    end
    return nil
end

local function acceptServer(obj, conf, beaver, bindAdd)
    local inst = setupInst(conf)

    local bfd = sockComm.setupSocket(conf)
    if bindAdd then
        bindAdd(conf.func, bfd, running())
    end

    CasyncAccept.new(beaver, bfd, conf)
    while true do
        local nfd, addr, ctx = yield()
        obj.new(beaver, nfd, bfd, addr, conf, inst, ctx)
    end
end

function M.acceptSetup(obj, beaver, conf, bindAdd)
    liteAssert(conf.mode == "TCP", format("bad accept mode: %s", conf.mode))
    local co = create(acceptServer)
    local res, msg = resume(co, obj, conf, beaver, bindAdd)
    coReport(co, res, msg)
end

return M