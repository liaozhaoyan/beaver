---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/7 8:43 AM
---

local require = require
local unistd = require("posix.unistd")
local CasyncPipeWrite = require("async.asyncPipeWrite")
local CasyncDns = require("async.asyncDns")
local system = require("common.system")
local log = require("common.log")
local buffer = require("string.buffer")

local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local lyaml = require("lyaml")
local M = {}

local mathHuge = math.huge
local ipairs = ipairs
local next = next
local print = print
local error = error
local time = os.time
local random = math.random
local pipe = unistd.pipe
local liteAssert = system.liteAssert
local coReport = system.coReport
local create = coroutine.create
local yield = coroutine.yield
local resume = coroutine.resume
local format = string.format
local running = coroutine.running
local create_beaver = c_api.create_beaver
local pipeEncode = buffer.encode
local ydump = lyaml.dump
local deepcopy = system.deepcopy
local tonumber = tonumber
local tostring = tostring
local mlog = log.mlog

local timer

local dnsOvertime = 30

local var = {
    setup = false,
    workers = {},   -- masters children

    dnsBuf = {},
}

function M.masterSetPipeOut(coOut)
    var.coOut = coOut
end

local function pipeOut(stream)
    local co = var.coOut
    local res, msg = resume(co, stream)
    coReport(co, res, msg)
end

local function workerPipeOut(beaver, fOut)
    local w = CasyncPipeWrite.new(beaver, fOut, 10)

    while true do
        local stream = yield()
        w:write(stream)
    end
end

--[==[
pipeCtrlReg call from entry.c, entry.c push master's in and out pipe fd to master
thread var set in masterSetVar, in proc function

]==]
local function pipeCtrlReg(arg)
    local res, msg

    if not var.setup then
        var.masterIn  = tonumber(arg[2]) or error(format("bad masterIn: %s", arg[2]))
        var.masterOut = tonumber(arg[3]) or error(format("bad masterOut: %s", arg[3]))

        local thread = var.thread
        local yaml = thread.yaml
        if yaml.worker then
            for _, worker in ipairs(yaml.worker) do
                local workerSend = deepcopy(worker)
                workerSend.number = nil
                local config = {worker = workerSend}
                config.log = yaml.log
                local configStr= ydump({config})
                for i = 1, worker.number do
                    local r, w, errno = pipe()
                    if not r then
                        error(format("create pipe failed, %s, errno %d", w, errno))
                    end
            
                    workerSend.id = i
                    configStr= ydump({config})
                    local pid = create_beaver(r, var.masterIn, worker.name or "worker", configStr)
    
                    local co = create(workerPipeOut)
                    res, msg = resume(co, thread.beaver, w)
                    coReport(co, res, msg)
                    var.workers[w] = {false, pid, r, co}   -- use w pipe to record single thread.
    
                    local func = {
                        "regThreadId",
                        w
                    }

                    res, msg = resume(co, pipeEncode(func))
                    coReport(co, res, msg)
                end
            end
        end

        var.setup = true
        pipeOut("ok.")
    end
    return 0
end

local function workerReg(arg)
    local w = arg[2]
    print(format("thread %d is already online", w))
    var.workers[w][1] = true
end

local function freshDns(domain, tVar)  -- {ip, time}
    var.dnsBuf[domain] = tVar
end

local function wakeDns(domain, ip, over, fid, coId)
    local func = {
        "echoDns",
        coId,
        domain,
        ip,
        over == mathHuge and -1 or over, -- -1 means no overtime, cannot encode by tonumber.
    }
    local co = var.workers[fid][4]  -- refer to pipeCtrlReg
    local res, msg = resume(co, pipeEncode(func))
    coReport(co, res, msg)
end

local function checkDns(domain)
    local buf = var.dnsBuf[domain]
    local now = time()
    if buf and now < buf[2] then
        return buf[1], buf[2]
    else
        var.dnsBuf[domain] = nil
        return nil
    end
end

local function randomIp(ips)
    -- ips is table, never nil
    local idx = random(#ips)
    return ips[idx]
end

local function reqDns(arg)
    local fid = arg[2]
    local coId = arg[3]
    local domain = arg[4]
    local ips, over

    ips, over = checkDns(domain)
    if ips then
        wakeDns(domain, randomIp(ips), over, fid, coId)
    else
        var.dns:request(domain, {fid, coId})
    end
end

local ping_seq = 1
local function ping(arg)
    local fid = arg[2]
    local coId = arg[3]
    local s = arg[4]

    local func = {
        "pong",
        coId,
        s,
        ping_seq,
    }
    ping_seq = ping_seq + 1
    local co = var.workers[fid][4]  -- refer to pipeCtrlReg
    local res, msg = resume(co, pipeEncode(func))
    coReport(co, res, msg)
end

local funcTable = {
    pipeCtrlReg = function(arg) return pipeCtrlReg(arg)  end,
    workerReg = function(arg) return workerReg(arg) end,
    reqDns = function(arg) return reqDns(arg)  end,
    ping = function(arg) return ping(arg) end,
    log = function(arg) return mlog(arg[2]) end,
}

function M.call(arg)
    if arg then
        return funcTable[arg[1]](arg)
    end
end

function M.msleep(ms)
    if ms < 1 then
        return
    end
    return timer:msleep(ms)
end

local function stripOverTimeDns(dnsBuf)
    local msleep = M.msleep
    while true do
        msleep(1000 * dnsOvertime / 5)
        local now = time()
        local domain, buf

        repeat
            domain, buf = next(dnsBuf, domain)
            if domain and now > buf[2] then
                dnsBuf[domain] = nil  -- strip.
            end
        until not domain
    end
end

local function stripDns(dnsBuf)
    local co = create(stripOverTimeDns)
    local res, msg = resume(co, dnsBuf)
    coReport(co, res, msg)
end

function M.masterSetVar(beaver, conf, yaml)
    timer = beaver:setupTimer()
    var.thread = {
        beaver = beaver,
        conf = conf,
        yaml = yaml,
    }

    var.dns = CasyncDns.new(beaver, freshDns, wakeDns, timer, dnsOvertime)
    stripDns(var.dnsBuf)   -- to anti dns leak, strip overtime dns.
end

function M.masterGetVar()
    return var.thread
end

return M