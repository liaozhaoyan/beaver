---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/7 8:43 AM
---

local unistd = require("posix.unistd")
local CasyncPipeWrite = require("async.asyncPipeWrite")
local CasyncDns = require("async.asyncDns")
local system = require("common.system")

local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local lyaml = require("lyaml")
local cjson = require("cjson.safe")

local M = {}

local ipairs = ipairs
local next = next
local print = print
local error = error
local time = os.time
local random = math.random
local pipe = unistd.pipe
local liteAssert = system.liteAssert
local coReport = system.coReport
local create = coroutine.create
local yield = coroutine.yield
local resume = coroutine.resume
local format = string.format
local running = coroutine.running
local create_beaver = c_api.create_beaver
local jencode = cjson.encode
local ydump = lyaml.dump
local deepcopy = system.deepcopy

local timer

local dnsOvertime = 30

local var = {
    setup = false,
    workers = {},   -- masters children

    dnsBuf = {},
}

function M.masterSetPipeOut(coOut)
    var.coOut = coOut
end

local function workerPipeOut(beaver, fOut)
    local w = CasyncPipeWrite.new(beaver, fOut, 10)

    while true do
        local stream = yield()
        local res, err, errno = w:write(stream)
        liteAssert(res, err)
    end
end

--[==[
pipeCtrlReg call from entry.c, entry.c push master's in and out pipe fd to master
thread var set in masterSetVar, in proc function

]==]
local function pipeCtrlReg(arg)
    local res, msg

    if not var.setup then
        var.masterIn  = arg["in"]
        var.masterOut = arg["out"]

        local thread = var.thread
        local yaml = thread.yaml
        if yaml.worker then
            for _, worker in ipairs(yaml.worker) do
                local workerSend = deepcopy(worker)
                workerSend.number = nil
                local config = {worker = workerSend}
                local configStr= ydump({config})
                for i = 1, worker.number do
                    local r, w, errno = pipe()
                    if not r then
                        error(format("create pipe failed, %s, errno %d", w, errno))
                    end
                 
                    workerSend.id = i
                    configStr= ydump({config})
                    local pid = create_beaver(r, var.masterIn, worker.name or "worker", configStr)
    
                    local co = create(workerPipeOut)
                    res, msg = resume(co, thread.beaver, w)
                    coReport(co, res, msg)
                    var.workers[w] = {false, pid, r, co}   -- use w pipe to record single thread.
    
                    local func = {
                        func = "regThreadId",
                        arg = {
                            id = w,
                        }
                    }
    
                    res, msg = resume(co, jencode(func))
                    coReport(var.coOut, res, msg)
                end
            end
        end

        var.setup = true
        local ret = {ret = 0}
        res, msg = resume(var.coOut, jencode(ret))
        coReport(var.coOut, res, msg)
    end
    return 0
end

local function workerReg(arg)
    local w = arg.id
    print(format("thread %d is already online", w))
    var.workers[w][1] = true
end

local function freshDns(domain, tVar)  -- {ip, time}
    var.dnsBuf[domain] = tVar
end

local function wakeDns(domain, ip, fid, coId)
    local func = {
        func = "echoDns",
        arg = {
            coId = coId,
            domain = domain,
            ip = ip
        }
    }
    local co = var.workers[fid][4]  -- refer to pipeCtrlReg
    local res, msg = resume(co, jencode(func))
    coReport(co, res, msg)
end

local function checkDns(domain)
    local buf = var.dnsBuf[domain]

    if buf then
            return buf[1]
    else
        return nil
    end
end

local function randomIp(ips)
    -- ips is table, never nil
    local idx = random(#ips)
    return ips[idx]
end

local function reqDns(arg)
    local fid = arg.id
    local coId = arg.coId
    local domain = arg.domain
    local ips

    ips = checkDns(domain)
    if ips then
        wakeDns(domain, randomIp(ips), fid, coId)
    else
        var.dns:request(domain, {fid, coId})
    end
end

local funcTable = {
    pipeCtrlReg = function(arg) return pipeCtrlReg(arg)  end,
    workerReg = function(arg) return workerReg(arg) end,
    reqDns = function(arg) return reqDns(arg)  end,
}

function M.call(arg)
    if arg then
        return funcTable[arg.func](arg.arg)
    end
end

function M.msleep(ms)
    if ms < 1 then
        return
    end
    return timer:msleep(ms)
end

local function stripOverTimeDns(dnsBuf)
    local msleep = M.msleep
    while true do
        msleep(1000 * dnsOvertime / 5)
        local now = time()
        local domain, buf

        while true do
            domain, buf = next(dnsBuf, domain)
            if domain then
                if now - buf[2] > dnsOvertime then
                    dnsBuf[domain] = nil  -- strip.
                end
            else
                break
            end
        end

    end
end

local function stripDns(dnsBuf)
    local co = create(stripOverTimeDns)
    local res, msg = resume(co, dnsBuf)
    coReport(co, res, msg)
end

function M.masterSetVar(beaver, conf, yaml)
    timer = beaver:setupTimer()
    var.thread = {
        beaver = beaver,
        conf = conf,
        yaml = yaml,
    }

    var.dns = CasyncDns.new(beaver, freshDns, wakeDns)
    stripDns(var.dnsBuf)
end

function M.masterGetVar()
    return var.thread
end

return M