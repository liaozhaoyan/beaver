---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/7 11:11 AM
---

local system = require("common.system")
local unistd = require("posix.unistd")
local psocket = require("posix.sys.socket")
local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local format = string.format
local newSocket = psocket.socket
local connect = psocket.connect

local M = {}

function M.setupSocket(conf)
    local res, fd, err, errno
    if conf.port then
        fd, err, errno = newSocket(psocket.AF_INET, psocket.SOCK_STREAM, 0)
        assert(fd, err)
        local tPort = {family=psocket.AF_INET, addr=conf.bind, port=conf.port}
        res = c_api.setsockopt_reuse_port(fd)
        assert(res == 0, format("reuse port failed, return %d.", res))
        res, err, errno = psocket.bind(fd, tPort)
        assert(res, err)
    elseif conf.uniSock then
        unistd.unlink(conf.uniSock)
        fd, err, errno = newSocket(psocket.AF_UNIX, psocket.SOCK_STREAM, 0)
        assert(fd, err)
        local tPort = {family=psocket.AF_UNIX, path=conf.uniSock, addr="", port=0}
        res, err, errno = psocket.bind(fd, tPort)
        assert(res, err)
    else
        error("bad bind mode.")
    end
    local backlog = conf.backlog or 100
    res, err, errno = psocket.listen(fd, backlog)
    assert(res, err)
    return fd
end

function M.connectSetup(tPort)
    local fd, err, errno
    if tPort.port then
        fd, err, errno = newSocket(psocket.AF_INET, psocket.SOCK_STREAM, 0)
        assert(fd, err)
    elseif tPort.path then
        unistd.unlink(tPort.path)
        fd, err, errno = newSocket(psocket.AF_UNIX, psocket.SOCK_STREAM, 0)
        assert(fd, err)
    else
        error("bad connect mode.")
    end
    return fd
end

local function tryConnect(fd, tConn)
    local res, err, errno

    res, err, errno = connect(fd, tConn)
    if not res then
        if errno == 115 then  -- need to wait.
            return 2  -- refer to aysync.asyncClient _init_ 2 connecting
        else
            error(format("socket connect %s, %d failed, report:%d, %s", tConn.addr, tConn.port, errno, err))
            return
        end
    else
        return res
    end
end

function M.connect(fd, tPort, beaver)
    local res = tryConnect(fd, tPort)
    if res == 2 then -- 2 means connecting  refer to aysync.asyncClient _init_
        beaver:mod_fd(fd, 1)  -- modify fd to writeable
        local connected = false
        repeat
            local e = coroutine.yield()
            if type(e) == "nil" then
                return 3 -- connected failed  refer to aysync.asyncClient _init_
            elseif e.ev_out > 0 then
                if c_api.check_connected(fd) == 0 then
                    connected = true
                    beaver:mod_fd(fd, 0)   -- modify fd to readonly
                    return 1  -- connected success  refer to aysync.asyncClient _init_
                else
                    return 3
                end
            elseif e.ev_close > 0 then
                return 3
            end
        until connected
    end
    return res
end

return M