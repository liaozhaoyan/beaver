---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/7 11:11 AM
---

local system = require("common.system")
local unistd = require("posix.unistd")
local psocket = require("posix.sys.socket")
local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local format = string.format
local type = type
local assert = assert
local error = error
local yield = coroutine.yield
local liteAssert = system.liteAssert
local newSocket = psocket.socket
local connect = psocket.connect
local vsock_socket = c_api.vsock_socket
local vsock_connect = c_api.vsock_connect
local vsock_bind = c_api.vsock_bind
local setsockopt_reuse_port = c_api.setsockopt_reuse_port
local check_connected = c_api.check_connected

local M = {}

function M.setupSocket(conf)
    local res, fd, err, errno
    if conf.port then
        fd, err, errno = newSocket(psocket.AF_INET, psocket.SOCK_STREAM, 0)
        liteAssert(fd, err)
        local tPort = {family=psocket.AF_INET, addr=conf.bind, port=conf.port}
        res = setsockopt_reuse_port(fd)
        liteAssert(res == 0, format("reuse port failed, return %d.", res))
        res, err, errno = psocket.bind(fd, tPort)
        liteAssert(res, err)
    elseif conf.uniSock then
        unistd.unlink(conf.uniSock)
        fd, err, errno = newSocket(psocket.AF_UNIX, psocket.SOCK_STREAM, 0)
        liteAssert(fd, err)
        local tPort = {family=psocket.AF_UNIX, path=conf.uniSock}
        res, err, errno = psocket.bind(fd, tPort)
        liteAssert(res, err)
    elseif conf.vsock then
        fd = vsock_socket(psocket.SOCK_STREAM, 0)
        if fd < 0 then
            error(format("vsock_socket failed, return %d.", fd))
        end
        res = vsock_bind(fd, conf.vsock.cid, conf.vsock.port)
        if res < 0 then
            error(format("vsock_bind failed, return %d.", res))
        end
    else
        error("bad bind mode.")
    end
    local backlog = conf.backlog or 100
    res, err, errno = psocket.listen(fd, backlog)
    liteAssert(res, err)
    return fd
end

function M.connectSetup(tPort)
    local fd, err, errno
    if tPort.port then
        fd, err, errno = newSocket(psocket.AF_INET, psocket.SOCK_STREAM, 0)
        liteAssert(fd, err)
    elseif tPort.path then
        fd, err, errno = newSocket(psocket.AF_UNIX, psocket.SOCK_STREAM, 0)
        liteAssert(fd, err)
        tPort.family = psocket.AF_UNIX
    elseif tPort.vsock then
        fd = vsock_socket(psocket.SOCK_STREAM, 0)
        if fd < 0 then
            error(format("vsock_socket failed, return %d.", fd))
        end
    else
        error("bad connect mode.")
    end
    return fd
end

local function tryConnect(fd, tPort)
    local res, err, errno

    if tPort.vsock then
        res = vsock_connect(fd, tPort.vsock.cid, tPort.vsock.port)
        if res > 0 then   -- connect not ready.
            errno = res
            err = format("vsock is not ready, report:%d.", errno)
            res = nil
        end
    else
        res, err, errno = connect(fd, tPort)
    end
    if not res then
        if errno == 115 then  -- need to wait.
            return 2  -- refer to aysync.asyncClient _init_ 2 connecting
        else
            if tPort.addr then
                error(format("socket connect %s:%d failed, report:%d, %s", tPort.addr, tPort.port, errno, err))
            elseif tPort.path then
                error(format("socket connect %s failed, report:%d, %s", tPort.path, errno, err))
            else
                error(format("socket connect failed, report:%d, %s", errno, err))
            end
            return
        end
    else
        return 1   -- 1 means connected
    end
end

function M.connect(fd, tPort, beaver)
    local res = tryConnect(fd, tPort)
    if res == 2 then -- 2 means connecting  refer to aysync.asyncClient _init_
        beaver:mod_fd(fd, 1)  -- modify fd to writeable
        local connected = false
        repeat
            local e = yield()
            if type(e) == "nil" then
                return 3 -- connected failed  refer to aysync.asyncClient _init_
            elseif type(e) ~= "cdata" then
                print(type(e), e)
                return 3 -- connected failed, unexpected event
            elseif e.ev_out > 0 then
                if check_connected(fd) == 0 then
                    connected = true
                    beaver:mod_fd(fd, 0)   -- modify fd to readonly
                    return 1  -- connected success  refer to aysync.asyncClient _init_
                else
                    return 3
                end
            elseif e.ev_close > 0 then
                return 3
            end
        until connected
    end
    return res
end

return M