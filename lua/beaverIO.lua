---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/12/31 4:34 PM
--- beaverIO manage all file io events.

local require = require
require("eclass")
require("struct")

local CbeaverIO = class("beaverIO")
local buffer = require("string.buffer")
local cffi = require("beavercffi")
local system = require("common.system")
local format = string.format

local ioBlockSize = 65536

local c_type, c_api = cffi.type, cffi.api

local s_unpack = struct.unpack
local s_pack = struct.pack
local concat = table.concat
local buffer_new = buffer.new
local liteAssert = system.liteAssert
local c_api_init = c_api.init
local c_api_deinit = c_api.deinit
local c_api_mod_fd = c_api.mod_fd
local c_api_del_fd = c_api.del_fd
local c_api_add_fd = c_api.add_fd
local c_api_b_close = c_api.b_close
local c_api_b_read = c_api.b_read
local c_api_b_write = c_api.b_write
local c_api_ssl_read = c_api.ssl_read
local c_api_ssl_write = c_api.ssl_write
local c_api_ssl_del = c_api.ssl_del
local c_api_b_yield = c_api.b_yield
local yield = coroutine.yield
local traceback = debug.traceback

function CbeaverIO:_init_()
    local efd = c_api_init(-1)
    liteAssert(efd > 0, traceback(format("init efd %d failed.", efd)))
    self._efd = efd
    self._ssl = {}
end

function CbeaverIO:_del_()
    if self._efd then
        c_api_deinit(self._efd)
    end
end

function CbeaverIO:remove(fd)
    liteAssert(c_api_del_fd(self._efd, fd) >= 0, traceback(format("del fd %d from epoll failed.", fd)))
    local handler = self._ssl[fd]
    if handler then
        c_api_ssl_del(handler)
        self._ssl[fd] = nil
    end
    liteAssert(c_api_b_close(fd) >= 0, traceback(format("close fd %d failed.", fd)))
end

function CbeaverIO:add(fd)
    liteAssert(c_api_add_fd(self._efd, fd) >= 0, "add fd failed.", traceback(format("add fd %d failed.", fd)))
end

function CbeaverIO:ssl_add(fd, handler)
    self._ssl[fd] = handler
end

function CbeaverIO:mod_fd(fd, wr)
    liteAssert(c_api_mod_fd(self._efd, fd, wr) == 0, traceback(format("mod fd %d failed.", fd)))
end

function CbeaverIO:_readFunction(fd)
    local handler = self._ssl[fd]
    if handler then
        return function (ptr, len)
            return c_api_ssl_read(handler, ptr, len)
        end
    else
        return function (ptr, len)
            return c_api_b_read(fd, ptr, len)
        end
    end
end

function CbeaverIO:read(fd, size)
    size = size or ioBlockSize
    local buf = buffer_new(size)
    local ptr, len = buf:reserve(size)

    len = len < size and len or size
    local readFucntion = self:_readFunction(fd)
    local ret = readFucntion(ptr, len)

    if ret == 0 then
        return nil, "fd closed",  64
    elseif ret > 0 then
        buf:commit(ret)
        return buf:tostring()
    elseif ret == -11 then
        local e = yield()
        if e.ev_close > 0 then
            return nil, format("fd %d is already closed.", fd), 32
        elseif e.ev_in > 0 then
            ret = readFucntion(ptr, len)
            if ret > 0 then
                buf:commit(ret)
                return buf:tostring()
            elseif ret == 0 then
                return nil, "fd closed",  64
            else
                return nil, "inner read IO Error.", -ret
            end
        else
            return nil, "top read IO Error.", -ret
        end
    end
end

function CbeaverIO:reads(fd, maxLen)
    maxLen = maxLen or 10 * 1024 * 1024 -- signal conversation accept 2M stream max
    local readFucntion = self:_readFunction(fd)

    local function readFd(tmo)
        local rfd, rMaxLen = fd, maxLen   -- local upvalue.
        local bufSize = rMaxLen < ioBlockSize and rMaxLen or ioBlockSize  -- min(maxLen, ioBlockSize)
        local buf = buffer.new(bufSize)
        local ptr, len = buf:reserve(bufSize)
        tmo = tmo or -1

        len = len < bufSize and len or bufSize   -- buffer min is 32, if maxLen little than 32,
        local ret = readFucntion(ptr, len)

        if ret == 0 then
            return nil, "fd closed",  64
        elseif ret > 0 then
            buf:commit(ret)
            return buf:tostring()
        elseif ret == -11 then
            self:co_set_tmo(rfd, tmo)
            local e = yield()
                    
            if e == nil then
                return nil, "yield error.", 5
            end
            if e.ev_close > 0 then
                return nil, format("fd %d is already closed.", fd), 32
            elseif e.ev_in > 0 then
                ret = readFucntion(ptr, len)
                if ret > 0 then
                    rMaxLen = rMaxLen - ret
                    buf:commit(ret)
                    return buf:tostring()
                elseif ret == 0 then
                    return nil, "fd closed",  64
                else
                    return nil, "inner reads IO Error.", -ret
                end
            else
                return nil, "top reads IO Error.", 5
            end
        end
    end
    return readFd
end

function CbeaverIO:_writeFunction(fd)
    local handler = self._ssl[fd]
    if handler then
        return function (ptr, len)
            return c_api_ssl_write(handler, ptr, len)
        end
    else
        return function (ptr, len)
            return c_api_b_write(fd, ptr, len)
        end
    end
end

function CbeaverIO:write(fd, stream)
    local res
    local ret

    local buf = buffer_new()
    buf:put(stream)
    local ptr, len = buf:ref()
    local writeFucntion = self:_writeFunction(fd)
    ret = writeFucntion(ptr, len)
    if ret == -11 then  -- full EAGAIN ?
        ret = 0
    end

    if ret >= 0 then
        if ret < len then
            res = c_api_mod_fd(self._efd, fd, 1)  -- epoll write ev
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end
            
            while ret < len do
                local e = yield()
                if e == nil then
                    return nil, "yield error.", 5
                end

                if e.ev_close > 0 then
                    return nil, format("write fd %d is already closed.", fd), 32
                elseif e.ev_out then
                    -- print("write fd %d need  to write %d.", fd, len - ret)
                    buf:skip(ret)  -- move to next

                    ptr, len = buf:ref()
                    ret = writeFucntion(ptr, len)
                    if ret < 0 then
                        if ret == -11 then  -- EAGAIN ?
                            ret = 0
                            goto continue
                        end
                        return nil, "innner write IO Error.", -ret
                    end
                else  -- need to read ? may something error.
                    return nil, "need to read ? may something error.", 5
                end
                ::continue::
            end

            ::done::
            res = c_api_mod_fd(self._efd, fd, 0)  -- epoll read ev only
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end
        end
        return 0
    else
        return nil, "top write IO Error.", -ret
    end
end

function CbeaverIO:readBySize(fd, size)  -- only for pipe, not for ssl socket
    local res, err, errno
    local len = 0
    local cnt = 1
    local buffs = {}

    local readFunc = self:reads(fd, size)

    repeat
        res, err, errno = readFunc()
        if res then
            len = len + #res
            buffs[cnt] = res
        else
            return res, err, errno
        end
    until len >= size
    return concat(buffs)
end

function CbeaverIO:pipeRead(fd)
    local res, err, errno

    res, err, errno = self:readBySize(fd, 4)
    if res then
        local len = s_unpack("<i", res)
        res, err, errno = self:readBySize(fd, len)
    end
    return res, err, errno
end

local function blockeWrite(func, fd, stream)
    local res
    local buf = buffer.new()
    buf:put(stream)
    local ptr, len = buf:ref()

    repeat
        res = c_api_b_write(fd, ptr, len)
        if res < 0 then
            if res == -11 then  -- EAGAIN ?
                res = 0
                c_api_b_yield()  -- thread should yield
            else
               return nil, "innner write IO Error.", -res 
            end
        end

        buf:skip(res)  -- move to next
        ptr, len = buf:ref()
    until len <= 0
    return 0
end

function CbeaverIO:pipeWrite(fd, stream)
    local len = #stream
    local buff = concat({s_pack("<i", len), stream})
    return blockeWrite(c_api.b_write, fd, buff)
end

return CbeaverIO
