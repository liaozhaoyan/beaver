---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/12/31 4:34 PM
--- beaverIO manage all file io events.


require("eclass")
require("struct")

local CbeaverIO = class("beaverIO")
local buffer = require("string.buffer")
local cffi = require("beavercffi")
local format = string.format

local ioBlockSize = 65536

local c_type, c_api = cffi.type, cffi.api

function CbeaverIO:_init_()
    local efd = c_api.init(-1)
    assert(efd > 0)
    self._efd = efd
end

function CbeaverIO:_del_()
    if self._efd then
        c_api.deinit(self._efd)
    end
end

function CbeaverIO:remove(fd)
    assert(c_api.del_fd(self._efd, fd) >= 0)
end

function CbeaverIO:add(fd)
    assert(c_api.add_fd(self._efd, fd) >= 0)
end

function CbeaverIO:mod_fd(fd, wr)
    assert(c_api.mod_fd(self._efd, fd, wr) == 0)
end

function CbeaverIO:read(fd, size)
    size = size or ioBlockSize
    local buf = buffer.new(size)
    local ptr, len = buf:reserve(size)

    len = len < size and len or size
    local ret = c_api.b_read(fd, ptr, len)

    if ret == 0 then
        return nil, "fd closed",  64
    elseif ret > 0 then
        buf:commit(ret)
        return buf:tostring()
    elseif ret == -11 then
        local e = coroutine.yield()
        if e.ev_close > 0 then
            return nil, format("fd %d is already closed.", fd), 32
        elseif e.ev_in > 0 then
            ret = c_api.b_read(fd, ptr, len)
            if ret > 0 then
                buf:commit(ret)
                return buf:tostring()
            elseif ret == 0 then
                return nil, "fd closed",  64
            else
                return nil, "inner read IO Error.", -ret
            end
        else
            return nil, "top read IO Error.", -ret
        end
    end
end

function CbeaverIO:reads(fd, maxLen)
    maxLen = maxLen or 10 * 1024 * 1024 -- signal conversation accept 2M stream max

    local function readFd(tmo)
        local bufSize = maxLen < ioBlockSize and maxLen or ioBlockSize  -- min(maxLen, ioBlockSize)
        local buf = buffer.new(bufSize)
        local ptr, len = buf:reserve(bufSize)
        tmo = tmo or -1

        len = len < bufSize and len or bufSize   -- buffer min is 32, if maxLen little than 32,
        local ret = c_api.b_read(fd, ptr, len)

        if ret == 0 then
            return nil, "fd closed",  64
        elseif ret > 0 then
            buf:commit(ret)
            return buf:tostring()
        elseif ret == -11 then
            self:co_set_tmo(fd, tmo)
            local e = coroutine.yield()
            if e.ev_close > 0 then
                return nil, format("fd %d is already closed.", fd), 32
            elseif e.ev_in > 0 then
                ret = c_api.b_read(fd, ptr, len)
                if ret > 0 then
                    maxLen = maxLen - ret
                    buf:commit(ret)
                    return buf:tostring()
                elseif ret == 0 then
                    return nil, "fd closed",  64
                else
                    return nil, "inner reads IO Error.", -ret
                end
            else
                return nil, "top reads IO Error.", 5
            end
        end
    end
    return readFd
end

function CbeaverIO:write(fd, stream)
    local res
    local ret

    local buf = buffer.new()
    buf:put(stream)
    local ptr, len = buf:ref()
    ret = c_api.b_write(fd, ptr, len)
    if ret == -11 then  -- full EAGAIN ?
        ret = 0
    end

    if ret >= 0 then
        if ret < len then
            res = c_api.mod_fd(self._efd, fd, 1)  -- epoll write ev
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end
            
            while ret < len do
                local e = coroutine.yield()

                if e.ev_close > 0 then
                    return nil, format("write fd %d is already closed.", fd), 32
                elseif e.ev_out then
                    print("write fd %d need  to write %d.", fd, len - ret)
                    buf:skip(ret)  -- move to next

                    ptr, len = buf:ref()
                    ret = c_api.b_write(fd, ptr, len)
                    if ret < 0 then
                        if ret == -11 then  -- EAGAIN ?
                            ret = 0
                            goto continue
                        end
                        return nil, "innner write IO Error.", -ret
                    end
                else  -- need to read ? may something error.
                    return nil, "need to read ? may something error.", 5
                end
                ::continue::
            end

            ::done::
            res = c_api.mod_fd(self._efd, fd, 0)  -- epoll read ev only
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end
        end
        return 0
    else
        return nil, "top write IO Error.", -ret
    end
end

function CbeaverIO:readBySize(fd, size)
    local res, err, errno
    local len = 0
    local cnt = 1
    local buffs = {}

    local readFunc = self:reads(fd, size)

    repeat
        res, err, errno = readFunc()
        if res then
            len = len + #res
            buffs[cnt] = res
        else
            return res, err, errno
        end
    until len >= size
    return table.concat(buffs)
end

function CbeaverIO:pipeRead(fd)
    local res, err, errno

    res, err, errno = self:readBySize(fd, 4)
    if res then
        local len = struct.unpack("<i", res)
        res, err, errno = self:readBySize(fd, len)
    end
    return res, err, errno
end

local function blockeWrite(func, fd, stream)
    local res
    local buf = buffer.new()
    buf:put(stream)
    local ptr, len = buf:ref()

    local write = c_api.b_write
    local yield = c_api.b_yield
    repeat
        res = write(fd, ptr, len)
        if res < 0 then
            if res == -11 then  -- EAGAIN ?
                res = 0
                yield()
            else
               return nil, "innner write IO Error.", -res 
            end
        end

        buf:skip(res)  -- move to next
        ptr, len = buf:ref()
    until len <= 0
    return 0
end

function CbeaverIO:pipeWrite(fd, stream)
    local len = #stream
    local buff = struct.pack("<i", len) .. stream
    return blockeWrite(c_api.b_write, fd, buff)
end

return CbeaverIO
