---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/12/31 4:34 PM
--- beaverIO manage all file io events.

local require = require
require("eclass")
require("struct")

local CbeaverIO = class("beaverIO")
local buffer = require("string.buffer")
local cffi = require("beavercffi")
local system = require("common.system")
local CworkerTimer =require("module.workerTimer")

local c_type, c_api = cffi.type, cffi.api

local type = type
local error = error
local s_unpack = struct.unpack
local s_pack = struct.pack
local concat = table.concat
local buffer_new = buffer.new
local liteAssert = system.liteAssert
local c_api_init = c_api.init
local c_api_deinit = c_api.deinit
local c_api_mod_fd = c_api.mod_fd
local c_api_del_fd = c_api.del_fd
local c_api_add_fd = c_api.add_fd
local c_api_b_close = c_api.b_close
local c_api_b_read = c_api.b_read
local c_api_b_write = c_api.b_write
local c_api_ssl_read = c_api.ssl_read
local c_api_ssl_write = c_api.ssl_write
local c_api_ssl_free = c_api.ssl_free
local c_api_ssl_shutdown = c_api.ssl_shutdown
local c_api_b_yield = c_api.b_yield
local yield = coroutine.yield
local running = coroutine.running
local traceback = debug.traceback
local format = string.format
local ioBlockSize = 65536

local timer

function CbeaverIO:_init_()
    local efd = c_api_init(-1)
    liteAssert(efd > 0, traceback(format("init efd %d failed.", efd)))
    self._efd = efd
    self._ssl = {}
    self._tmoFd = {}
    self._cos = {}
end

function CbeaverIO:_del_()
    if self._efd then
        c_api_deinit(self._efd)
    end
end

function CbeaverIO:setupTimer()  -- should be called in master or worker.
    timer = CworkerTimer.new(self)
    timer:start()
    return timer
end

function CbeaverIO:co_set_tmo(fd, tmo)
    liteAssert(tmo < 0 or tmo >= 0.002, format("illegal tmo value: %d, should >= 0.002.", tmo))
    self._tmoFd[fd] = tmo
end

function CbeaverIO:timerWait(fd)
    local co = running()
    local function clear()
        timer:wait(co, -1)
    end
    timer:wait(co, self._tmoFd[fd] * 1000)

    return clear
end

function CbeaverIO:remove(fd)
    liteAssert(c_api_del_fd(self._efd, fd) >= 0, traceback(format("del fd %d from epoll failed.", fd)))
    local handler = self._ssl[fd]
    if handler then  -- for ssl socket, should shutdown first. then close fd, then free at last.
        c_api_ssl_shutdown(handler)
        self._ssl[fd] = nil
    end
    liteAssert(c_api_b_close(fd) >= 0, traceback(format("close fd %d failed.", fd)))
    if handler then
        c_api_ssl_free(handler)
    end
    if self._tmoFd[fd] then  -- clear timer.
        timer:wait(self._tmoFd[fd], -1)
        self._tmoFd[fd] = nil
    end
end

function CbeaverIO:add(fd)
    liteAssert(c_api_add_fd(self._efd, fd) >= 0, "add fd failed.", traceback(format("add fd %d failed.", fd)))
end

function CbeaverIO:ssl_add(fd, handler)
    if self._ssl[fd] then
        error("ssl handler already exists.")
    end
    self._ssl[fd] = handler
end

function CbeaverIO:mod_fd(fd, wr)
    return c_api_mod_fd(self._efd, fd, wr)
    -- liteAssert(c_api_mod_fd(self._efd, fd, wr) == 0, traceback(format("mod fd %d failed.", fd)))
end

function CbeaverIO:sslHandler(fd)
    return self._ssl[fd]
end

function CbeaverIO:_readFunction(fd)
    local handler = self._ssl[fd]
    if handler then
        return function (ptr, len)
            return c_api_ssl_read(handler, ptr, len)
        end
    else
        return function (ptr, len)
            return c_api_b_read(fd, ptr, len)
        end
    end
end

function CbeaverIO:read(fd, size)
    size = size or ioBlockSize
    local buf = buffer_new(size)
    local ptr, len = buf:reserve(size)

    len = len < size and len or size
    local readFucntion = self:_readFunction(fd)
    local ret = readFucntion(ptr, len)

    if ret == 0 then
        return nil, "fd closed",  64
    elseif ret > 0 then
        buf:commit(ret)
        return buf:tostring()
    elseif ret == -11 then  -- again
        ::again_wait:: 
        local co = running()
        timer:wait(co, self._tmoFd[fd] * 1000)
        local e = yield()
        timer:wait(co, -1)
        local t = type(e)
        if e == nil then
            return nil, "fd closed",  64
        elseif t == "number" then  -- number means time out
            return -e, "time out.", 5
        elseif t ~= "cdata" then
            error(format("beaver report error. bad type(e):%s", t))
        end
        if e.ev_close > 0 then
            return nil, format("fd %d is already closed.", fd), 32
        elseif e.ev_in > 0 then
            ret = readFucntion(ptr, len)
            if ret > 0 then
                buf:commit(ret)
                return buf:tostring()
            elseif ret == -11 then  -- for ssl socket， may returns -11 to wait more data.
                goto again_wait
            elseif ret == 0 then
                return nil, "fd closed",  64
            else
                return nil, "inner read IO Error.", -ret
            end
        else
            return nil, "top read IO Error.", -ret
        end
    else
        return nil, "top read IO Error.", -ret
    end
end

function CbeaverIO:reads(fd, maxLen, tmo)
    maxLen = maxLen or 10 * 1024 * 1024 -- signal conversation accept 2M stream max
    local readFucntion = self:_readFunction(fd)

    local function readFd()
        local rfd, rMaxLen = fd, maxLen   -- local upvalue.
        local bufSize = rMaxLen < ioBlockSize and rMaxLen or ioBlockSize  -- min(maxLen, ioBlockSize)
        local buf = buffer.new(bufSize)
        local ptr, len = buf:reserve(bufSize)
        tmo = tmo or -1

        len = len < bufSize and len or bufSize   -- buffer min is 32, if maxLen little than 32,
        local ret = readFucntion(ptr, len)

        if ret == 0 then
            return nil, "fd closed",  64
        elseif ret > 0 then
            buf:commit(ret)
            return buf:tostring()
        elseif ret == -11 then
            ::again_wait::
            local co = running()
            timer:wait(co, tmo * 1000)
            local e = yield()
            timer:wait(co, -1)
            local t = type(e)
            if e == nil then
                return nil, "fd closed",  64
            elseif t == "number" then  -- number means time out
                return -e, "time out.", 5
            elseif t ~= "cdata" then
                error(format("beaver report error. bad type(e):%s", t))
            end
            if e.ev_close > 0 then
                return nil, format("fd %d is already closed.", rfd), 32
            elseif e.ev_in > 0 then
                ret = readFucntion(ptr, len)
                if ret > 0 then
                    rMaxLen = rMaxLen - ret
                    buf:commit(ret)
                    return buf:tostring()
                elseif ret == -11 then  -- for ssl socket， may returns -11 to wait more data.
                    goto again_wait
                elseif ret == 0 then
                    return nil, "fd closed",  64
                else
                    return nil, "inner reads IO Error.", -ret
                end
            else
                return nil, "top reads IO Error.", 5
            end
        else
            return nil, "top read IO Error.", -ret
        end
    end
    return readFd
end

function CbeaverIO:_writeFunction(fd)
    local handler = self._ssl[fd]
    if handler then
        return function (ptr, offset, len)
            return c_api_ssl_write(handler, ptr, offset, len)
        end
    else
        return function (ptr, offset, len)
            return c_api_b_write(fd, ptr, offset, len)
        end
    end
end

function CbeaverIO:write(fd, stream)
    local res
    local ret

    local offset = 0
    local len = #stream
    local writeFucntion = self:_writeFunction(fd)
    ret = writeFucntion(stream, offset, len)
    if ret == -11 then  -- full EAGAIN ?
        ret = 0
    end

    if ret >= 0 then
        if ret < len then
            res = c_api_mod_fd(self._efd, fd, 1)  -- epoll write ev
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end

            while len > ret do
                len = len - ret
                offset = offset + ret

                local co = running()
                timer:wait(co, self._tmoFd[fd] * 1000)
                local e = yield()
                timer:wait(co, -1)
                local t = type(e)
                if e == nil then
                    return nil, "fd closed",  64
                elseif t == "number" then  -- number means time out
                    return -e, "time out.", 5
                elseif t ~= "cdata" then
                    error(format("beaver report error. bad type(e):%s", t))
                end

                if e.ev_close > 0 then
                    return nil, format("write fd %d is already closed.", fd), 32
                elseif e.ev_out then
                    -- print("write fd %d need  to write %d.", fd, len - ret)
                    ret = writeFucntion(stream, offset, len)
                    if ret < 0 then
                        if ret == -11 then  -- EAGAIN ?
                            ret = 0
                            goto continue
                        end
                        return nil, "innner write IO Error.", -ret
                    end
                else  -- need to read ? may something error.
                    return nil, "need to read ? may something error.", 5
                end
                ::continue::
            end

            res = c_api_mod_fd(self._efd, fd, 0)  -- epoll read ev only
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end
        end
        return 0
    else
        return nil, "top write IO Error.", -ret
    end
end

function CbeaverIO:readBySize(fd, size)  -- only for pipe, not for ssl socket
    local res, err, errno
    local len = 0
    local cnt = 1
    local buffs = {}

    local readFunc = self:reads(fd, size)

    repeat
        res, err, errno = readFunc()
        if res then
            len = len + #res
            buffs[cnt] = res
        else
            return res, err, errno
        end
    until len >= size
    return concat(buffs)
end

function CbeaverIO:pipeRead(fd)
    local res, err, errno

    res, err, errno = self:readBySize(fd, 4)
    if res then
        local len = s_unpack("<i", res)
        res, err, errno = self:readBySize(fd, len)
    end
    return res, err, errno
end

function CbeaverIO:pipeWrite(fd, stream)
    local len = #stream
    local buff = s_pack("<i", len) .. stream
    return self:write(fd, buff)
end

return CbeaverIO
