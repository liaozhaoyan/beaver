---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/12/31 4:34 PM
--- beaverIO manage all file io events.


require("eclass")
require("struct")

local CbeaverIO = class("beaverIO")
local cffi = require("beavercffi")
local unistd = require("posix.unistd")

local c_type, c_api = cffi.type, cffi.api

function CbeaverIO:_init_()
    local efd = c_api.init(-1)
    assert(efd > 0)
    self._efd = efd
end

function CbeaverIO:_del_()
    if self._efd then
        c_api.deinit(self._efd)
    end
end

function CbeaverIO:remove(fd)
    assert(c_api.del_fd(self._efd, fd) >= 0)
end

function CbeaverIO:add(fd)
    assert(c_api.add_fd(self._efd, fd) >= 0)
end

function CbeaverIO:read(fd, len)
    len = len or 4096
    local s, err, errno
    s, err, errno = unistd.read(fd, len)

    if s then
        if #s > 0 then
            return s
        else
            return nil, "fd closed",  64
        end
    elseif errno == 11 then
        local e = coroutine.yield()
        if e.ev_close > 0 then
            return nil, string.format("fd %d is already closed.", fd), 32
        elseif e.ev_in > 0 then
            s, err, errno = unistd.read(fd, len)
            if s then
                if #s > 0 then
                    return s
                else
                    return nil, "fd closed",  64
                end
            else
                return nil
            end
            return s, err, errno
        else
            return nil, "IO Error.", 5
        end
    end
end

function CbeaverIO:reads(fd, maxLen)
    maxLen = maxLen or 2 * 1024 * 1024  -- signal conversation accept 2M stream max
    local function readFd()
        local s, err, errno
        s, err, errno = unistd.read(fd, maxLen)
        if s then
            if #s > 0 then
                return s
            else
                return nil, "fd closed",  64
            end
        elseif errno == 11 then  -- EAGAIN
            local e = coroutine.yield()
            if e.ev_close > 0 then
                return nil, string.format("fd %d is already closed.", fd), 32
            elseif e.ev_in > 0 then
                s, err, errno = unistd.read(fd, maxLen)
                if s then
                    local len = #s
                    if len > 0 then
                        maxLen = maxLen - #s
                        return s
                    else
                        return nil, "fd closed",  64
                    end
                else
                    return s, err, errno
                end
            else
                return nil, "IO Error.", 5
            end
        end
    end
    return readFd
end

function CbeaverIO:write(fd, stream)
    local sent, err, errno
    local res

    sent, err, errno = unistd.write(fd, stream)
    if sent ~= nil then
        if sent < #stream then  -- send buffer may full
            res = c_api.mod_fd(self._efd, fd, 1)  -- epoll write ev
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end

            while sent < #stream do
                local e = coroutine.yield()
                if e.ev_close > 0 then
                    return nil, string.format("fd %d is already closed.", fd), 32
                elseif e.ev_out then
                    stream = string.sub(stream, sent + 1)
                    if stream == nil then
                        goto done
                    end
                    sent, err, errno = unistd.write(fd, stream)
                    if sent == nil then
                        if errno == 11 then  -- EAGAIN ?
                            sent = 0
                            goto continue
                        end
                        return nil, err, errno
                    end
                else  -- need to read ? may something error.
                    return nil, "need to read ? may something error.", 5
                end
                ::continue::
            end

            ::done::
            res = c_api.mod_fd(self._efd, fd, 0)  -- epoll read ev only
            if res < 0 then
                return nil, "epoll mod_fd failed.", -res
            end
        end
        return 0
    else
        return nil, err, errno
    end
end

function CbeaverIO:readBySize(fd, size)
    local res, err, errno
    local len = 0
    local cnt = 1
    local buffs = {}

    local readFunc = self:reads(fd, size)

    repeat
        res, err, errno = readFunc()
        if res then
            len = len + #res
            buffs[cnt] = res
        else
            return res, err, errno
        end
    until len >= size
    return table.concat(buffs)
end

function CbeaverIO:pipeRead(fd)
    local res, err, errno

    res, err, errno = self:readBySize(fd, 4)
    if res then
        local len = struct.unpack("<i", res)
        res, err, errno = self:readBySize(fd, len)
    end
    return res, err, errno
end

function CbeaverIO:pipeWrite(fd, stream)
    local len = #stream
    local buff = struct.pack("<i", len) .. stream
    return self:write(fd, buff)
end

return CbeaverIO
