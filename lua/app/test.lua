---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/18 4:44 PM
---

require("eclass")

local cjson = require("cjson.safe")
local system = require("common.system")
local workVar = require("module.workVar")
local pystring = require("pystring")
local ChttpReq = require("http.httpReq")
local ChttpPool = require("http.httpPool")
local ChttpKeepPool = require("http.httpKeepPool")
local httpRead = require("http.httpRead")
local request = require("http.request")
local Credis = require("client.redis")
local CcliBase = require("client.cliBase")
local socket = require("socket")
local digest = require("common.digest")
local bit = require("bit")
local posix = require("posix")
local unistd = require("posix.unistd")
local CperfFd = require("client.perfFd")
local Cpopen = require("client.popen")
local executor = require("client.excute")
local redisTest = require("app.redisTest")
local CclickHouse = require("client.clickHouse")

local class = class
local Ctest = class("test")
local collectgarbage = collectgarbage
local string = string
local sha256 = digest.sha256
local unpack = unpack
local jencode = cjson.encode
local execute = executor.execute
local http_get = request.get
local parseParams = httpRead.parseParams
local getenv = os.getenv
local split = pystring.split

local beaver = workVar.workerGetVar().beaver
local getIp = workVar.getIp
local pingMaster = workVar.pingMaster

collectgarbage("setpause", 150)
collectgarbage("setstepmul", 300)

local counter = 0

local function index(tReq)
    counter = counter + 1
    return {body = string.format("beaver %d say hello.", counter)}
end

local proxy
local pool = ChttpPool.new()
local keepConfig = {
    host = "https://www.baidu.com",
}
local keepPool = ChttpKeepPool.new(keepConfig)

local function setupPorxy()
    local http_proxy = getenv("http_proxy")
    if http_proxy then
        local _, body = unpack(split(http_proxy, "//"))
        if body then
            local host, port = unpack(split(body, ":"))
            if host and tonumber(port) then
                proxy = {
                    ip = host,
                    port = tonumber(port),
                }
                print("proxy:", proxy.ip, proxy.port)
                keepConfig.proxy = proxy
            end
        end
    end
end

local function keepPoolTest(tReq)
    local tRes, msg = keepPool:get("https://www.baidu.com/")
    if tRes then
        return {body = tRes.body}
    else
        return {body = msg}
    end
end

local function poolTest(tReq)
    local tRes, msg = pool:get("http://www.baidu.com")
    if tRes then
        return {body = tRes.body}
    else
        return {body = msg}
    end
end

local function instance(tReq)
    local tRes, msg = http_get("http://100.100.100.200/latest/meta-data/instance-id", nil, nil, tReq)
    if tRes then
        return tRes
    else
        return {body = msg, code = 403}
    end
end

local function bing(tReq)
    local req = ChttpReq.new(tReq, "http://cn.bing.com/", nil, nil, proxy)
    local tRes, msg = req:get("HTTP://cn.bing.com/")
    if tRes then
        return {body = tRes.body}
    else
        return {body = msg, code = 403}
    end
end

local function baidu(tReq)
    local req = ChttpReq.new(tReq, "http://www.baidu.com/", nil, nil, proxy)
    local tRes, msg = req:get("HTTP://www.baidu.com/")
    if tRes then
        return {body = tRes.body}
    else
        return {body = msg, code =403}
    end
end

local function singleGet(tReq, url, coWake)
    return function ()
        print("start get ", url, socket.gettime())
        local req = ChttpReq.new(tReq, url, nil, nil, proxy)
        local tRes = req:get(url)
        coroutine.resume(coWake, url, tRes.body)
    end
end

local function head(tReq)
    local url = "http://www.baidu.com/"
    local req = ChttpReq.new(tReq, url, nil, nil, proxy)
    local tRes = req:head(url)
    if tRes then
        system.dumps(tRes.headers)
        return {body = "ok"}
    else
        return {body = "unknown"}
    end
end

local function bulk(tReq)
    local urls = {"https://cn.bing.com/", "http://www.baidu.com/"}

    for _, url in ipairs(urls) do
        local coFunc = singleGet(tReq, url, coroutine.running())
        local co = coroutine.create(coFunc)
        local ok, res = coroutine.resume(co)
        assert(ok, res)
    end

    local c = 0
    while c < #urls do
        local url, body = coroutine.yield()
        if not url then
            break
        end
        print("get done:", url, socket.gettime())
        c = c + 1
    end
    return {body = "done"}
end

local function unkown(tReq)
    local req = ChttpReq.new(tReq, "www.unknown.com")
    local tRes = req:get("HTTP://www.unknown.com/")
    if tRes then
        print(tRes.body)
        return {body = tRes.body}
    end
end

local function svg(tReq)
    parseParams(tReq)
    system.dumps(tReq)
    local body = [[<svg width="100" height="100">
    <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
  </svg>]]
    return {
        body = body,
        headers = {
            ["Content-Type"] = "image/svg+xml",
        }
    }
end

local function var(tReq)
    local param = tReq.Param["var"]
    return {
        body = string.format("url set: %s", tostring(param))
    }
end

local function rcmd(tReq)
    local r = Credis.new(tReq, "127.0.0.1", 6379, nil, "alibaba")
    local s = tReq.body

    local cmd, argStr = unpack(split(s, " ", 1))
    local args = {}
    if argStr then
        args = split(argStr, ":")
    end
    local res = r[cmd](r, unpack(args))

    if res then
        if type(res) == "table" then
            res = cjson.encode(res)
        end
        return {body = res}
    end
end

local function gcInfo(tReq)
    return {body = string.format("mem: %d", collectgarbage("count"))}
end

local function rcmds(tReq)
    local r = Credis.new(tReq, "127.0.0.1", 6379, nil, "alibaba")
    local pipe = r:pipeline()

    local s = tReq.body
    local cmds = split(s, "\n")
    for _, cmdLine in ipairs(cmds) do
        local cmd, argStr = unpack(split(cmdLine, " ", 1))
        local args = {}
        if argStr then
            args = split(argStr, ":")
        end
        pipe[cmd](pipe, unpack(args))
    end
    local res = pipe:send()
    r:close()
    if res then
        return {body = cjson.encode(res)}
    end
end

local function uds(tReq)
    local tPort = {path = "db.sock"}
    local cli = CcliBase.new(tReq.beaver, tPort)
    local res = cli:echo("hello, uds.")
    cli:close()
    if res then
        return {body = cjson.encode(res)}
    end
end

local function dns(tReq)
    parseParams(tReq)
    if tReq.queries and tReq.queries["domain"] then
        local domain = tReq.queries["domain"]
        local ip = getIp(domain)
        return {body = string.format("domain: %s, ip: %s", domain, ip)}
    else
        return {body = "no domain."}
    end
end

local function sha_check()
    local s = "hello world."
    return {body = sha256(s)}
end

local function probe(code)
    print("code: ", code)
end

local function testKmsg()
    local fd = posix.open("/dev/kmsg", posix.O_RDONLY + posix.O_NONBLOCK)
    if fd then
        local res, err, errno
        print("open /dev/kmsg: fd", fd)
        res, err, errno = unistd.lseek(fd, 0, posix.SEEK_END)
        if not res then
            print("lseek error:", err, errno)
            posix.close(fd)
            return
        end

        local function cb(_fd)
            local s = beaver:read(_fd)
            print("read from kmsg fd:", s)
            return 0
        end
        local function cbEvent(_fd, event)
            print("kmsg event:", _fd, event)
            return 0
        end
        CperfFd.new(beaver, fd, cb, cbEvent, -1)  -- -1 never timeout
    end
end

local function testPipe()
    local fd = posix.open("/tmp/beaver_fifo", posix.O_RDONLY + posix.O_NONBLOCK)
    if fd then
        print("open: fd", fd)
        local function cb(_fd)
            local s = beaver:read(_fd)
            print("read from fd:", s)
            return 0
        end
        local function cbEvent(_fd, event)
            print(fd, event)
            return 0
        end
        CperfFd.new(beaver, fd, cb, cbEvent, 2)
    end
end

local function testPopen()
    local p
    local function cb(fd)
        local s = beaver:read(fd)
        print("read from fd:", s)
        return 0
    end
    local function cbEvent(fd, event)
        print("evnet", fd, event)
        if event == 1 then
            local rets = p:wait()
            print("pid stat:", rets[1][2], "pid: code:", rets[1][3])
        end
        return 0
    end
    p = Cpopen.new(beaver, {"ls", "-l"}, cb, cbEvent)
end

local function clickHouse()
    local ck = CclickHouse.new("http://172.16.3.178:8123", "prof", "prof", "Sysom123")
    -- local ok, msg = ck:execute("SELECT COUNT(beg) FROM prof_on;")
    local ok, res = ck:execute("SELECT beg, instance, content FROM prof_on WHERE beg == 1734276180;")
    if ok then
        return {body = jencode(res)}
    else
        return {body = res, code = "400"}
    end
end

local function ping(tReq)
    local s, seq = "hello", nil
    s, seq = pingMaster(s)
    return {body = string.format("ping: %s, seq: %d", s, seq)}
end

local function _ping(i)
    local s, seq = "hello" .. i, nil
    s, seq = pingMaster(s)
    if seq % 100 == 0 then
        print("ping ok, seq:", seq)
    end
    -- print("ping ok, seq:", seq)
end

local function pings(tReq)
    for i = 1, 10000 do
        local co = coroutine.create(_ping)
        coroutine.resume(co, i)
    end
    return {body = "pings ok."}
end

function Ctest:_init_(inst, conf)
    setupPorxy()
    -- redisTest.start()
    -- inst:setProbe(probe)
    inst:get("/", index)
    inst:get("/instance", instance)
    inst:get("/bing", bing)
    inst:get("/baidu", baidu)
    inst:get("/head", head)
    inst:get("/bulk", bulk)
    inst:get("/unkown", unkown)
    inst:get("/gc", gcInfo)
    inst:get("/svg", svg)
    inst:get("/var/:var", var)
    inst:post("/rcmd", rcmd)
    inst:post("/rcmds", rcmds)
    inst:get("/uds", uds)
    inst:get("/dns", dns)
    inst:get("/sha", sha_check)
    inst:get("/pool", poolTest)
    inst:get("/keep", keepPoolTest)
    inst:get("/clickhouse", clickHouse)
    inst:get("/ping", ping)
    inst:get("/pings", pings)
    testPipe()
    testPopen()
    testKmsg()
    -- print(execute("sleep 10"))
end

return Ctest
