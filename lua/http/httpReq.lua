---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/19 12:26 AM
---

require("eclass")

local system = require("common.system")
local psocket = require("posix.sys.socket")
local CasyncBase = require("async.asyncBase")
local workVar = require("module.workVar")
local sockComm = require("module.sockComm")
local httpRead = require("http.httpRead")
local httpComm = require("http.httpComm")
local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api

local ChttpReq = class("request", CasyncBase)

local ip_pattern = "(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)"

local function match_ip(ip)
    local d1, d2, d3, d4 = ip:match(ip_pattern)
    if d1 and d2 and d3 and d4 then
        local num1, num2, num3, num4 = tonumber(d1), tonumber(d2), tonumber(d3), tonumber(d4)
        if num1 >= 0 and num1 <= 255 and num2 >= 0 and num2 <= 255 and num3 >= 0 and num3 <= 255 and num4 >= 0 and num4 <= 255 then
            return true
        end
    end
    return false
end

local function getIp(host)
    local domain, ip
    if match_ip(host) then
        ip = host
    else
        domain, ip = workVar.dnsReq(host)
        assert(domain == host, "bad dns request.")
    end
    return ip
end

function ChttpReq:_init_(tReq, host, port, tmo, proxy, maxLen)
    local beaver = tReq.beaver
    self._domain = host
    local ip

    if proxy then
        ip, port = proxy.ip, proxy.port
    else
        ip, port = getIp(host), port or 80
    end

    self._http = httpComm.new()

    tmo = tmo or 30
    self._maxLen = maxLen or 2 * 1024 * 1024

    local tPort = {family=psocket.AF_INET, addr=ip, port=port}
    local fd = sockComm.connectSetup(tPort)
    self._tPort = tPort

    self._coWake = coroutine.running()
    self._status = 0  -- 0:disconnect, 1 connected, 2 connecting

    CasyncBase._init_(self, beaver, fd, tmo)
    assert(self:_waitConnected(beaver, tReq.fd) == 0, "connect socket failed.")
    self._hostFd = tReq.fd
end

function ChttpReq:_del_()
    self:close()
end

local function wake(co, v)
    local res, msg
    if coroutine.status(co) == "suspended" then
        res, msg = coroutine.resume(co, v)
        system.coReport(co, res, msg)
        return msg
    end
end

function ChttpReq:_setup(fd, tmo)
    local beaver = self._beaver
    local co = self._coWake
    local maxLen = self._maxLen
    local status, res
    local e

    workVar.connectAdd("httpReq", fd, coroutine.running())

    self._status = 2  -- connecting
    beaver:co_set_tmo(fd, tmo)  -- set connect timeout
    status = sockComm.connect(fd, self._tPort, beaver)
    beaver:co_set_tmo(fd, -1)   -- back
    self._status = status  -- connected
    e = wake(co, status)  -- connected

    while status == 0 do
        if not e then
            e = coroutine.yield()
        end
        local t = type(e)
        if t == "string" then -- has data to send
            beaver:co_set_tmo(fd, tmo)
            res = beaver:write(fd, e)
            if not res then
                break
            end
            e = nil
            beaver:co_set_tmo(fd, -1)
        elseif t == "nil" then  -- host closed
            wake(co, nil)
            break
        else  -- read event.
            if e.ev_close > 0 then
                break
            elseif e.ev_in > 0 then
                local fread = beaver:reads(fd, maxLen)
                local tRes = httpRead.clientRead(fread)
                e = wake(co, tRes)
                t = type(e)
                if t == "cdata" then -->upstream need to close.
                    assert(e.ev_close > 0)
                    wake(co, nil)  -->let upstream to do next working.
                    break
                elseif t == "number" then  -->upstream reuse connect
                    e = nil
                end
            else
                print("IO Error.")
                break
            end
        end
    end

    self._status = 1  -- connected
    self:stop()
    c_api.b_close(fd)
    workVar.connectDel("httpReq", fd)
end

function ChttpReq:_waitConnected(beaver, fd)  -- this fd is server fd,
    local res = self._status
    if res == 0 then -- connect ok.
        return 0
    elseif res == 2 then -- connecting
        beaver:mod_fd(fd, -1)  -- mask io event, only close event is working.
        local w = coroutine.yield()
        beaver:mod_fd(fd, 0)  -- back host fd to read mode
        local t = type(w)
        if t == "number" then  -- 0 is ok
            return w
        else
            print("wake from self.", t, w, w.ev_close, w.ev_in, w.ev_out)
            return 1
        end
    else  -- 1 connect failed
        return 1
    end
end

function ChttpReq:_waitData(stream)
    local beaver = self._beaver
    local coWake = self._co
    local selfFd = self._hostFd

    local status = self._status

    if status == 0 then -- connect ok.
        local res, msg
        local e

        local statCo = coroutine.status(coWake)
        if statCo == "suspended" then
            res, msg = coroutine.resume(coWake, stream)
            system.coReport(coWake, res, msg)
            beaver:mod_fd(selfFd, -1)  -- to block fd other event, mask io event, only close event is working.
            e = coroutine.yield()
            beaver:mod_fd(selfFd, 0)  -- back to read mode
        elseif statCo == "normal" then    -- wake from http client.
            e = coroutine.yield(stream)
        else
            return nil
        end

        local t = type(e)
        if t == "table" then
            return e
        else
            return nil
        end
    else
        return nil
    end
end

local function setupHeader(headers)
    headers = headers or {}
    if not headers.Accept then
        headers.Accept = "text/*, application/json, image/*, application/octet-stream"
    end
    return headers
end

local function checkKeepAlive(res)
    if not res then -- nil, bad response
        return false
    end

    if res.headers and res.headers.connection then
        if res.headers.connection == "close" then
            return false
        end
    end
    return true
end

function ChttpReq:post(uri, headers, body, reuse)
    headers = headers or {}
    headers.Host = self._domain
    local res = {
        url = uri,
        method = "POST",
        headers = setupHeader(headers),
        body = body or "",
    }
    local stream = self._http:packClientFrame(res)
    local res = self:_waitData(stream)
    if not reuse or not checkKeepAlive(res) then
        self:close()
    end
    return res
end

function ChttpReq:get(uri, headers, body, reuse)
    headers = headers or {}
    headers.Host = self._domain
    local res = {
        url = uri,
        method = "GET",
        headers = setupHeader(headers),
        body = body or "",
    }
    local stream = self._http:packClientFrame(res)
    local res = self:_waitData(stream)
    if not reuse or not checkKeepAlive(res) then
        self:close()
    end
    return res
end

function ChttpReq:put(uri, headers, body, reuse)
    headers = headers or {}
    headers.Host = self._domain
    local res = {
        url = uri,
        method = "PUT",
        headers = setupHeader(headers),
        body = body or "",
    }
    local stream = self._http:packClientFrame(res)
    local res = self:_waitData(stream)
    if not reuse or not checkKeepAlive(res) then
        self:close()
    end
    return res
end

function ChttpReq:delete(uri, headers, body, reuse)
    headers = headers or {}
    headers.Host = self._domain
    local res = {
        url = uri,
        method = "DELETE",
        headers = setupHeader(headers),
        body = body or "",
    }
    local stream = self._http:packClientFrame(res)
    local res = self:_waitData(stream)
    if not reuse or not checkKeepAlive(res) then
        self:close()
    end
    return res
end

function ChttpReq:close()
    if self._status ~= 1 then
        local e = c_type.new("native_event_t")
        e.ev_close = 1
        e.fd = self._fd
        self:_waitData(e)
    end
end

return ChttpReq
