---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/19 12:26 AM
---

local require = require
require("eclass")

local psocket = require("posix.sys.socket")
local posix = require("posix")
local CasyncClient = require("async.asyncClient")
local system = require("common.system")
local workVar = require("module.workVar")
local sockComm = require("common.sockComm")
local httpRead = require("http.httpRead")
local httpComm = require("http.httpComm")
local cffi = require("beavercffi")
local c_type, c_api = cffi.type, cffi.api
local stat = posix.sys.stat

local format = string.format
local liteAssert = system.liteAssert
local type = type
local print = print
local running = coroutine.running
local yield = coroutine.yield
local error = error
local assert = assert
local fstat = stat.stat
local clientRead = httpRead.clientRead

local httpConnectTmo = 10

local class = class
local ChttpReq = class("request", CasyncClient)

function ChttpReq:_init_(tReq, host, port, tmo, proxy, maxLen)
    local ip
    local tPort
    local host_t = type(host)

    if host_t == "table" then   -- is a table , may uds or kata socket.
        local path
        if host.path then
            path = host.path
            assert(fstat(path))
            self._domain = path
        else
            error("not support socket type.")
        end

        if host.kata and port then
           self._kataPort = port
        end
        tPort = {family=psocket.AF_UNIX, path=host.path}
    elseif host_t == "string" then
        self._domain = host
        if proxy then
            ip, port = proxy.ip, proxy.port
        else
            ip, port = workVar.getIp(host), port or 80
        end
        tPort = {family=psocket.AF_INET, addr=ip, port=port}
    else
        error(format("host type: %s", host_t))
    end

    tmo = tmo or 60
    self._maxLen = maxLen or 2 * 1024 * 1024
    self._reuse = false   -- not reuse connect in default condition.
    tReq.clients[self] = true

    CasyncClient._init_(self, tReq, tReq.fd, tPort, tmo)
end

function ChttpReq:_setup(fd, tmo)
    local beaver = self._beaver
    local co = self._coWake
    local maxLen = self._maxLen
    local status, res
    local e

    workVar.connectAdd("httpReq", fd, running())

    status, e = self:cliConnect(fd, tmo)

    if status == 1 and self._kataPort then
        status = self:_connKata(fd, beaver, co)
        self._status = status  -- 当期状况可能会去唤醒 等待co，co可能会在get等方法中访问self._status状态，必须要提前设置
        if status == 1 then
            e = self:wake(co, true) -- 连接成功, 接下来的数据将会通过co 传递过来。
        else
            self:wake(co, false)  -- 连接失败
        end
    end

    while status == 1 do
        if not e then
            e = yield()
        end
        local t = type(e)
        if t == "string" then -- has data to send
            beaver:co_set_tmo(fd, tmo)
            res = beaver:write(fd, e)
            if not res then
                break
            end
            e = nil
            beaver:co_set_tmo(fd, -1)
        elseif t == "nil" then  -- host closed
            self:wake(co, nil)
            break
        else  -- read event.
            if e.ev_close > 0 then
                break
            elseif e.ev_in > 0 then
                local fread = beaver:reads(fd, maxLen)
                local tRes = clientRead(fread)
                e = self:wake(co, tRes)
                t = type(e)
                if t == "cdata" then -->upstream need to close.
                    liteAssert(e.ev_close > 0, "cdata should be ev_close")
                    self:wake(co, nil)  -->let upstream to do next working.
                    break
                elseif t == "number" then  -->upstream reuse connect
                    e = nil
                end
            else
                print("IO Error.")
                break
            end
        end
    end

    self._status = 0  -- closed
    self:stop()
    c_api.b_close(fd)
    workVar.connectDel("httpReq", fd)
end

function ChttpReq:_connKata(fd, beaver, co)
    local port = self._kataPort
    local res = beaver:write(fd, format("connect %d\n", port))
    if not res then
        return 0
    end

    beaver:co_set_tmo(fd, httpConnectTmo)

    local e = yield()
    local t = type(e)
    if t == "nil" then  -- fd has closed.
        return 0
    elseif t == "cdata" then  -- has data to read
        if e.ev_close > 0 then   -- fd closed.
            return 0
        elseif e.ev_in > 0 then  -- has data to read
            res = beaver:read(fd, 1024)
            if not res then
                return 0
            end
            beaver:co_set_tmo(fd, -1)
            return 1
        else
            print("IO Error.")
        end
    else
        print(format("type: %s, undknown error.", t))
    end
    return 0
end

function ChttpReq:kataReady()
    local ok = yield()  --only kata need to wait
    return ok
end

function ChttpReq:reuse(resue)
    self._reuse = resue
end

local function setupHeader(headers)
    headers = headers or {}
    if not headers.Accept then
        headers.Accept = "text/*, application/json, image/*, application/octet-stream"
    end
    return headers
end

local function checkKeepAlive(res)
    if not res then -- nil, bad response
        return false
    end

    if res.headers and res.headers.connection then
        if res.headers.connection == "close" then
            return false
        end
    end
    return true
end

local commPackClientFrame = httpComm.packClientFrame
function ChttpReq:_req(verb, uri, headers, body, reuse)
    if self._status ~= 1 then
        return {body = format("connected %s status is %d, should be 1.", self._domain, self._status), 
                code = 500}
    end
    headers = headers or {}
    headers.Host = self._domain
    local sendTable = {
        url = uri,
        method = verb,
        headers = setupHeader(headers),
        body = body or "",
    }
    local stream = commPackClientFrame(sendTable)
    local res, msg = self:_waitData(stream)
    if type(res) ~= "table" then
        -- closed by remote server.
        print(format("closed by remote server: %s", msg))
        return nil
    end
    if reuse or self._reuse then
        return res
    end
    self:close()
    return res
end

function ChttpReq:post(uri, headers, body, reuse)
    return self:_req("POST", uri, headers, body, reuse)
end

function ChttpReq:get(uri, headers, body, reuse)
    return self:_req("GET", uri, headers, body, reuse)
end

function ChttpReq:put(uri, headers, body, reuse)
    return self:_req("PUT", uri, headers, body, reuse)
end

function ChttpReq:delete(uri, headers, body, reuse)
    return self:_req("DELETE", uri, headers, body, reuse)
end

return ChttpReq
