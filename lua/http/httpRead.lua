---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/18 6:51 PM
---

-- refer to https://blog.csdn.net/zx_emily/article/details/83024065

local M = {}
local sockerUrl = require("socket.url")
local pystring = require("pystring")
local zlib = require("zlib")

local split = pystring.split
local lstrip = pystring.lstrip
local type = type
local ipairs = ipairs
local print = print
local unpack = unpack
local tonumber = tonumber
local tostring = tostring
local find = string.find
local sub = string.sub
local format = string.format
local lower = string.lower
local concat = table.concat
local insert = table.insert
local pcall = pcall
local inflate = zlib.inflate

local defaultHttpReadOvertime = 10

local function _inflate(data)
    local inflater = zlib.inflate()
    local success, decompressed_data = pcall(inflater, data, "finish")
    if success then
        return decompressed_data
    else
        return nil
    end
end

local decompress_func = {
    ["deflate"] = _inflate,
    ["gzip"] = _inflate
}

local function transfer_encoding(tRes)
    local headers = tRes.headers
    local func = decompress_func[headers["content-encoding"]]
    if func then
        tRes.body = func(tRes.body)
        if tRes.body == nil then
            tRes.code = 501
            tRes.body = "decompress error."
        end
    else
        tRes.code = 501
        tRes.body = "not support content-encoding: " .. headers["content-encoding"]
    end
end

local function parseParam(param)
    local tParam = split(param, "&")
    local res = {}
    for _, s in ipairs(tParam) do
        local kv = split(s, "=", 1)
        if #kv ~= 2 then
            print(format("bad param %s", tostring(s)))
            return nil
        end
        local k = sockerUrl.unescape(kv[1])
        local v = sockerUrl.unescape(kv[2])
        res[k] = v
    end
    return res
end

function M.parseParams(tUrl)
    if tUrl.query then
        tUrl.queries = parseParam(tUrl.query)
    end
    if tUrl.params then
        tUrl.paramses = parseParam(tUrl.params)
    end
    return tUrl
end

function M.parseUrl(url, parseParam)
    local tUrl = sockerUrl.parse(url)  -- refer to https://lunarmodules.github.io/luasocket/url.html
    if parseParam then
        return M.parseParams(tUrl)
    else
        return tUrl
    end
end

local function waitDataRest(fread, rest, tReq)
    local len = 0
    local tStream = {tReq.body}
    local c = #tStream
    while len < rest do
        local s = fread()
        local t = type(s)
        if t == "string" then
            len = len + #s
            c = c + 1
            tStream[c] = s
        else
            -- print(format("waitDataRest type: %s, unknown error., %s", t, tostring(s)))
            return -1
        end
    end
    tReq.body = concat(tStream)
    return 0
end

local function waitChuckData(fread, s, size)
    while true do
        if #s >= size + 2 then
            return s
        end
        local add = fread()
        local t = type(add)
        if t == "string" then
            s = concat({s, add})
        else
            -- print(format("chunk data type: %s, unknown error., %s", t, tostring(s)))
            return nil
        end
    end
end

local function waitChuckSize(fread, s)
    while true do
        if find(s, "\r\n") then
            return s
        end
        local add, msg = fread()
        local t = type(add)
        if t == "string" then
            s = concat({s, add})
        else
            -- print(format("chunk size type: %s, undnown error., %s", t, msg))
            return nil
        end
    end
end

local function readChunks(fread, tReq)
    local cells = {}
    local s = tReq.body
    local size
    local len = 1
    local bodies, body

    while true do
        if len == 0 then
            break
        end
        s = waitChuckSize(fread, s)
        if s then
            size, s = unpack(split(s, "\r\n", 1))
            len = tonumber(size, 16)
            if len then
                bodies = waitChuckData(fread, s, len)
                if bodies then
                    body = sub(bodies, 1, len)
                    s = sub(bodies, len + 2)
                    insert(cells, body)
                else
                    return -2
                end
            else
                return -3
            end
        else
            return -1
        end
    end
    tReq.body = concat(cells)
    return 0
end

local function waitHttpRest(fread, tReq)
    local length = tReq.headers["content-length"]
    if length then
        local lenData = #tReq.body
        local lenInfo = tonumber(length)

        local rest = lenInfo - lenData
        if rest > 200 * 1024 * 1024 then  -- limit max body len
            return -1
        end

        if waitDataRest(fread, rest, tReq) < 0 then
            return -2
        end
    else  -- chunk mode
        local chunked = tReq.headers["transfer-encoding"]
        if chunked == "chunked" or (tReq.body and #tReq.body > 0) then
            if readChunks(fread, tReq) < 0 then
                return -3
            end
        else
            tReq.body = ""  --empty body.
        end
    end
    return 0
end

local function waitHttpHead(fread)
    local stream = ""
    while true do
        local s, msg = fread()
        local t = type(s)
        if t == "string" then
            stream = concat({stream, s})
            if find(stream, "\r\n\r\n") then
                return stream
            end
        else
            return nil, msg
        end
    end
end

local function serverParse(fread, stream, parseParam)
    local tStatus = split(stream, "\r\n", 1)
    if #tStatus < 2 then
        print("bad stream format.")
        return nil
    end

    local stat, heads = unpack(tStatus)
    local tStat = split(stat, " ", 2)
    if #tStat < 3 then
        print(format("bad stat: %s", tostring(stat)))
        return nil
    end

    local verb, url, version = unpack(tStat)
    local tReq
    tReq = M.parseUrl(url, parseParam)
    tReq.verb = lower(verb)
    tReq.version = version
    tReq.origUrl = url

    local tHead = split(heads, "\r\n\r\n", 1)
    if #tHead < 2 then
        print(format("bad head: %s", tostring(heads)))
        return nil
    end
    local headerStr, body = unpack(tHead)
    local tHeader = split(headerStr, "\r\n")
    local headers = {}
    for _, s in ipairs(tHeader) do
        local tKv = split(s, ":", 1)
        if #tKv < 2 then
            print(format("bad head kv value: %s", tostring(s)))
            return nil
        end
        local k, v = unpack(tKv)
        k = lower(k)
        headers[k] = lstrip(v)
    end

    tReq.headers = headers
    tReq.body = body
    if waitHttpRest(fread, tReq) < 0 then
        return nil
    end

    if headers["content-encoding"] then
        transfer_encoding(tReq)
    end
    return tReq
end

function M.serverRead(fread, parseParam)
    local stream, msg = waitHttpHead(fread)
    if stream == nil then   -- read return stream or error code or nil
        return nil, msg
    end
    return serverParse(fread, stream, parseParam)
end

local function clientParse(fread, stream, headType)
    local tStatus = split(stream, "\r\n", 1)
    if #tStatus < 2 then
        print("bad stream format.")
        return nil
    end

    local stat, heads = unpack(tStatus)
    local tStat = split(stat, " ", 2)
    if #tStat < 3 then
        print(format("bad stat: %s", tostring(stat)))
        return nil
    end

    local vers, code, descr = unpack(tStat)
    local tRes = {
        vers = vers,
        code = code,
        descr = descr
    }

    local tHead = split(heads, "\r\n\r\n", 1)
    if #tHead < 2 then
        print(format("bad head: %s", tostring(heads)))
        return nil
    end
    local headerStr, body = unpack(tHead)
    local tHeader = split(headerStr, "\r\n")
    local headers = {}
    for _, s in ipairs(tHeader) do
        local tKv = split(s, ":", 1)
        if #tKv < 2 then
            print(format("bad head kv value: %s", tostring(s)))
            return nil
        end
        local k, v = unpack(tKv)
        k = lower(k)
        headers[k] = lstrip(v)
    end

    tRes.headers = headers
    tRes.body = body

    if headType then
        return tRes
    end
    if waitHttpRest(fread, tRes) < 0 then
        return nil
    end
    if headers["content-encoding"] then
        transfer_encoding(tRes)
    end
    return tRes
end

function M.clientRead(fread, headType, tmo)
    local stream, msg = waitHttpHead(fread)
    if stream == nil then   -- read return stream or error code or nil
        return nil, msg
    end
    return clientParse(fread, stream, headType)
end

return M
