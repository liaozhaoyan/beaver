---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2024/1/3 9:13 PM
---

--- refer to https://blog.csdn.net/a19881029/article/details/14002273
local require = require
local pystring = require("pystring")
local system = require("common.system")
local sio = require("common.sio")
local sockerUrl = require("socket.url")
local zlib = require("zlib")
local struct = require("struct")

local tostring = tostring
local tonumber = tonumber
local find = string.find
local char = string.char
local pack = struct.pack
local print = print
local ipairs = ipairs
local pairs = pairs
local concat = table.concat
local split = pystring.split
local map_format = pystring.map_format
local url_unescape = sockerUrl.unescape
local url_parse = sockerUrl.parse
local format = string.format
local os_date = os.date
local os_time = os.time
local type = type
local gizps = sio.gizps
local deflate = zlib.deflate
local crc32 = zlib.crc32

local mt = {}

local function parseParam(param)
    local tParam = split(param, "&")
    local res = {}
    for _, s in ipairs(tParam) do
        local kv = split(s, "=")
        if #kv ~= 2 then
            print(format("bad param %s", s))
            return nil
        end
        local k = url_unescape(kv[1])
        local v = url_unescape(kv[2])
        res[k] = v
    end
    return res
end

local function bodisLen(bodis)
    local len = 0
    for i = 1, #bodis do
        if type(bodis[i]) == "string" then
            len = len + #bodis[i]
        else
            return -1
        end
    end
    return len
end

local function parseParams(tUrl)
    if tUrl.query then
        tUrl.queries = parseParam(tUrl.query)
    end
    if tUrl.params then
        tUrl.paramses = parseParam(tUrl.params)
    end
    return tUrl
end

function mt.parsePath(path)
    local res = url_parse(path)
    return parseParams(res)
end

local codeStrTable = {
    [100] = "Continue",
    [200] = "Ok",
    [201] = "Created",
    [202] = "Accepted",
    [204] = "No Content",
    [206] = "Partial Content",
    [301] = "Moved Permanently",
    [302] = "Found",
    [304] = "Not Modified",
    [400] = "Bad Request",
    [401] = "Unauthorized",
    [403] = "Forbidden",
    [404] = "Not Found",
    [405] = "Not Acceptable",
    [418] = "I'm a beaver",
    [424] = "Failed Dependency",
    [500] = "Internal Server Error",
    [501] = "Not Implemented",
    [503] = "Service Unavailable",
}
local function packStat(code)   -- only for server.
    code = code or 200
    return {"HTTP/1.1", " ", tostring(code), " ", codeStrTable[code] or "Unkonwn", "\r\n"}
end

local function packServerHeaders(streams, c, headers, len, zip) -- just for http out.
    if zip then
        headers["Content-Encoding"] = zip
    end
    if not headers["Content-Length"] then
        headers["Content-Length"] = len
    end
    if not headers["Date"] then
        headers["Date"] = os_date("%a, %d %b %Y %H:%M:%S %Z", os_time())
    end
    if not headers["Server"] then
        headers["Server"] = "beaver/0.1.0"
    end

    for k, v in pairs(headers) do
        streams[c + 1] = k
        streams[c + 2] = ": "
        streams[c + 3] = tostring(v)
        streams[c + 4] = "\r\n"
        c = c + 4
    end
    c = c + 1
    streams[c] = "\r\n"
    return c
end

local function _deflate(data)
    local compressor = deflate(5, 15)
    return compressor(data, "finish")
end

local plainTextType = {
    ["text/plain"] = true,
    ["text/html"] = true,
    ["text/css"] = true,
    ["application/x-www-form-urlencoded"] = true,
    ["application/javascript"] = true,
    ["application/xml"] = true,
    ["application/json"] = true,
    ["application/xhtml+xml"] = true,
    ["application/atom+xml"] = true,
    ["application/x-protobuf"] = true,
    ["application/x-thrift"] = true,
}

local typeLen = {
    string = function(body) return #body, body end,
    table = function(body) return bodisLen(body), body end,
    number = function(body) local s = tostring(body); return s, #s end,
    boolean = function(body) local s = tostring(body); return s, #s end,
    ["nil"] = function(body) return 0, "" end,
    ["function"] = function(body) return -1, nil end,
    ["thread"] = function(body) return -1, nil end,
    ["userdata"] = function(body) return -1, nil end
}

function mt.packServerFrame(res)
    local body = res.body
    local t = type(body)
    local len
    len, body = typeLen[t](body)
    if len < 0 then
        return nil, "body has illegal type." .. t
    end

    if not res.headers then
        res.headers = {
            ["Content-Type"] = "text/plain",
        }
    end

    local zip = nil
    local encoding = res["accept-encoding"]
    if encoding and len >= 512 and plainTextType[res.headers["Content-Type"]] then
        if find(encoding, "deflate") then
            zip = "deflate"
            if t =="table" then  -- only table need to transfer_encoding
                t = "string"
                body = concat(body)
                body = _deflate(body)
            else
                body = _deflate(body)
            end
            len = #body
        elseif find(encoding, "gzip") then
            zip = "gzip"
            if t =="table" then  -- only table need to transfer_encoding
                body = concat(body)  -- body is string
                body = gizps(body, "a")
            else -- string
                body = gizps(body, "a")
            end
             t = "table"
             len = bodisLen(body)
        end
    end

    local stream , c = packStat(res.code), 6
    if t == "table" then
        c = packServerHeaders(stream, c, res.headers, len, zip)
        for i = 1, #body do
            c = c + 1
            stream[c] = body[i]
        end
    else
        c = packServerHeaders(stream, c, res.headers, len, zip) + 1
        stream[c] = body
    end
    if c > 1024 then
        return nil, "stream is too long. len: " .. c
    end
    return stream, c
end

local function packCliLine(method, uri)
    return {method, " ",  uri, " ", "HTTP/1.1", "\r\n"}
end

local acceptEncoding = "deflate, gzip"
local function packCliHeaders(streams, c, headers, len)
    len = len or 0

    if not headers then
        headers = {
            ["Content-Type"] = "text/plain",
        }
    end
    if not headers["Content-Length"] and len > 0 then
        headers["Content-Length"] = tostring(len)
    end
    if not headers["Accept-Encoding"] and acceptEncoding then
        headers["Accept-Encoding"] = acceptEncoding
    end
    if not headers["User-Agent"] then
        headers["User-Agent"] = "beaverCli/0.1.0"
    end
    if not headers["Connection"] then
        headers["Connection"] = "Keep-Alive"
    end

    for k, v in pairs(headers) do
        streams[c + 1] = k
        streams[c + 2] = ": "
        streams[c + 3] = tostring(v)
        streams[c + 4] = "\r\n"
        c = c + 4
    end

    c = c + 1
    streams[c] = "\r\n"
    return c
end

function mt.packClientFrame(res)
    local streams, c = packCliLine(res.method, res.uri), 6 -- has 6 cells, so index is 6
    local t = type(res.body)
    local len, body = typeLen[t](res.body)
    if len < 0 then
        return nil, "body has illegal type." .. t
    end

    if t == "table" then   -- only table need to transfer_encoding
        c = packCliHeaders(streams, c, res.headers, len)
        for i = 1, #body do
            c = c + 1
            streams[c] = body[i]
        end
    else
        c = packCliHeaders(streams, c, res.headers, len) + 1
        streams[c] = body
    end

    return streams, c
end

function mt.setEncoding(coding)
    if #coding > 0 then
        acceptEncoding = coding
    else
        acceptEncoding = false
    end
end

return mt
